<!DOCTYPE html>
<html lang="en" class="theme-light">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chat - MinouChat</title>

    <!-- Prevent theme flash -->
    <script>
        (function() {
            const saved = localStorage.getItem('minouchat-theme');
            const theme = saved || (window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light');
            document.documentElement.classList.remove('theme-light', 'theme-dark');
            document.documentElement.classList.add('theme-' + theme);
        })();
    </script>

    <!-- Lucide Icons -->
    <script src="https://unpkg.com/lucide@latest/dist/umd/lucide.min.js"></script>

    <link rel="stylesheet" href="{{ url_for('static', path='css/theme.css') }}">

    <style>
        html, body {
            height: 100%;
            overflow: hidden;
        }

        .chat-layout {
            display: flex;
            height: 100vh;
        }

        /* Sidebar */
        .chat-sidebar {
            width: 280px;
            background: var(--bg-primary);
            border-right: 1px solid var(--border-color);
            display: flex;
            flex-direction: column;
            transition: width var(--transition-normal), margin var(--transition-normal);
        }

        .chat-sidebar.collapsed {
            width: 0;
            margin-left: -1px;
            overflow: hidden;
        }

        .sidebar-header {
            padding: var(--space-4);
            border-bottom: 1px solid var(--border-subtle);
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .sidebar-header a {
            color: var(--text-primary);
            font-weight: var(--font-semibold);
            font-size: var(--text-lg);
        }

        /* Persona Dropdown */
        .persona-dropdown-wrapper {
            padding: var(--space-3);
            border-bottom: 1px solid var(--border-subtle);
        }

        .persona-dropdown {
            width: 100%;
            padding: var(--space-3);
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: var(--radius-md);
            color: var(--text-primary);
            font-size: var(--text-sm);
            cursor: pointer;
            appearance: none;
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='16' height='16' viewBox='0 0 24 24' fill='none' stroke='%23888' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Cpath d='m6 9 6 6 6-6'/%3E%3C/svg%3E");
            background-repeat: no-repeat;
            background-position: right 12px center;
            padding-right: 40px;
        }

        .persona-dropdown:focus {
            outline: none;
            border-color: var(--text-primary);
        }

        /* New Chat Button */
        .new-chat-wrapper {
            padding: var(--space-2) var(--space-3);
        }

        .new-chat-btn {
            width: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: var(--space-2);
            padding: var(--space-3);
            background: var(--bg-primary);
            border: 1px dashed var(--border-color);
            border-radius: var(--radius-md);
            color: var(--text-secondary);
            font-size: var(--text-sm);
            cursor: pointer;
            transition: all var(--transition-fast);
        }

        .new-chat-btn:hover {
            border-style: solid;
            border-color: var(--text-primary);
            color: var(--text-primary);
            background: var(--bg-secondary);
        }

        /* Conversation History */
        /* Sidebar Documents Section */
        .sidebar-documents {
            padding: var(--space-3);
            border-bottom: 1px solid var(--border-subtle);
            max-height: 280px;
            overflow-y: auto;
        }

        .sidebar-section-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: var(--space-2);
        }

        .sidebar-section-header h4 {
            display: flex;
            align-items: center;
            gap: var(--space-2);
            font-size: var(--text-sm);
            font-weight: var(--font-medium);
            color: var(--text-primary);
            margin: 0;
        }

        /* Todo List Styles */
        .todo-list {
            display: flex;
            flex-direction: column;
            gap: var(--space-1);
        }

        .todo-item {
            display: flex;
            align-items: flex-start;
            gap: var(--space-2);
            padding: var(--space-2);
            background: var(--bg-secondary);
            border-radius: var(--radius-sm);
            transition: background var(--transition-fast);
        }

        .todo-item:hover {
            background: var(--bg-tertiary);
        }

        .todo-item.completed .todo-text {
            text-decoration: line-through;
            color: var(--text-muted);
        }

        .todo-checkbox {
            flex-shrink: 0;
            margin-top: 2px;
        }

        .todo-checkbox input {
            width: 16px;
            height: 16px;
            cursor: pointer;
            accent-color: var(--pop-primary);
        }

        .todo-text {
            flex: 1;
            font-size: var(--text-sm);
            color: var(--text-primary);
            word-break: break-word;
            line-height: 1.4;
        }

        .todo-delete {
            opacity: 0;
            padding: var(--space-1);
            background: transparent;
            border: none;
            color: var(--text-muted);
            cursor: pointer;
            transition: opacity var(--transition-fast);
            display: flex;
            align-items: center;
        }

        .todo-item:hover .todo-delete {
            opacity: 1;
        }

        .todo-delete:hover {
            color: var(--pop-danger);
        }

        /* Priority indicators */
        .todo-priority-1 { border-left: 3px solid var(--pop-danger); }
        .todo-priority-2 { border-left: 3px solid var(--pop-warning); }
        .todo-priority-3 { border-left: 3px solid var(--text-muted); }

        .todo-add-form {
            margin-top: var(--space-2);
            display: flex;
            flex-direction: column;
            gap: var(--space-2);
        }

        .todo-add-actions {
            display: flex;
            gap: var(--space-2);
            justify-content: flex-end;
        }

        /* Goals List Styles */
        .goals-list {
            display: flex;
            flex-direction: column;
            gap: var(--space-2);
        }

        .goal-item {
            padding: var(--space-2);
            background: var(--bg-secondary);
            border-radius: var(--radius-sm);
            cursor: pointer;
            transition: background var(--transition-fast);
        }

        .goal-item:hover {
            background: var(--bg-tertiary);
        }

        .goal-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            gap: var(--space-2);
            margin-bottom: var(--space-1);
        }

        .goal-title {
            font-size: var(--text-sm);
            font-weight: 500;
            color: var(--text-primary);
            flex: 1;
        }

        .goal-progress-bar {
            height: 4px;
            background: var(--bg-tertiary);
            border-radius: 2px;
            overflow: hidden;
        }

        .goal-progress-fill {
            height: 100%;
            background: var(--pop-primary);
            border-radius: 2px;
            transition: width var(--transition-base);
        }

        .goal-meta {
            display: flex;
            justify-content: space-between;
            margin-top: var(--space-1);
            font-size: var(--text-xs);
            color: var(--text-muted);
        }

        /* Habits List Styles */
        .habits-list {
            display: flex;
            flex-direction: column;
            gap: var(--space-1);
        }

        .habit-item {
            display: flex;
            align-items: center;
            gap: var(--space-2);
            padding: var(--space-2);
            background: var(--bg-secondary);
            border-radius: var(--radius-sm);
            transition: background var(--transition-fast);
        }

        .habit-item:hover {
            background: var(--bg-tertiary);
        }

        .habit-check-btn {
            width: 24px;
            height: 24px;
            border-radius: 50%;
            border: 2px solid var(--border-color);
            background: transparent;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all var(--transition-fast);
            flex-shrink: 0;
        }

        .habit-check-btn:hover {
            border-color: var(--pop-primary);
        }

        .habit-check-btn.completed {
            background: var(--pop-primary);
            border-color: var(--pop-primary);
            color: white;
        }

        .habit-info {
            flex: 1;
            min-width: 0;
        }

        .habit-title {
            font-size: var(--text-sm);
            color: var(--text-primary);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .habit-streak {
            font-size: var(--text-xs);
            color: var(--text-muted);
        }

        .habit-streak.active {
            color: var(--pop-warning);
        }

        /* Life Areas Scorecard */
        .life-areas-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: var(--space-2);
        }

        .life-area-item {
            display: flex;
            flex-direction: column;
            gap: 2px;
            padding: var(--space-2);
            background: var(--bg-secondary);
            border-radius: var(--radius-sm);
            cursor: pointer;
            transition: all var(--transition-fast);
        }

        .life-area-item:hover {
            background: var(--bg-tertiary);
        }

        .life-area-name {
            font-size: 10px;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .life-area-score {
            display: flex;
            align-items: center;
            gap: var(--space-1);
        }

        .life-area-score-value {
            font-size: var(--text-base);
            font-weight: var(--font-medium);
            color: var(--text-primary);
            min-width: 20px;
        }

        .life-area-bar {
            flex: 1;
            height: 4px;
            background: var(--bg-tertiary);
            border-radius: var(--radius-full);
            overflow: hidden;
        }

        .life-area-bar-fill {
            height: 100%;
            background: var(--pop-primary);
            transition: width var(--transition-normal);
        }

        /* Score color coding */
        .score-low { color: var(--pop-danger) !important; }
        .score-medium { color: var(--pop-warning) !important; }
        .score-high { color: var(--pop-success) !important; }

        .life-areas-average {
            font-size: var(--text-sm);
            font-weight: var(--font-medium);
            color: var(--text-secondary);
            background: var(--bg-secondary);
            padding: 2px 8px;
            border-radius: var(--radius-sm);
        }

        .conversation-history {
            flex: 1;
            overflow-y: auto;
            padding: var(--space-2) var(--space-3);
        }

        .history-group {
            margin-bottom: var(--space-4);
        }

        .history-group-label {
            font-size: var(--text-xs);
            font-weight: var(--font-semibold);
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.05em;
            padding: var(--space-2) var(--space-2);
            margin-bottom: var(--space-1);
        }

        .conversation-item {
            display: flex;
            align-items: center;
            gap: var(--space-2);
            padding: var(--space-2) var(--space-3);
            border-radius: var(--radius-md);
            cursor: pointer;
            transition: all var(--transition-fast);
            margin-bottom: var(--space-1);
            position: relative;
        }

        .conversation-item:hover {
            background: var(--bg-secondary);
        }

        .conversation-item.active {
            background: var(--bg-tertiary);
        }

        .conversation-item-icon {
            flex-shrink: 0;
            width: 16px;
            height: 16px;
            color: var(--text-muted);
        }

        .conversation-item-title {
            flex: 1;
            font-size: var(--text-sm);
            color: var(--text-primary);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .conversation-item-delete {
            opacity: 0;
            padding: var(--space-1);
            background: transparent;
            border: none;
            color: var(--text-muted);
            cursor: pointer;
            border-radius: var(--radius-sm);
            transition: all var(--transition-fast);
            flex-shrink: 0;
        }

        .conversation-item:hover .conversation-item-delete {
            opacity: 1;
        }

        .conversation-item-delete:hover {
            color: var(--pop-danger);
            background: rgba(239, 68, 68, 0.1);
        }

        .history-empty {
            text-align: center;
            padding: var(--space-6) var(--space-4);
            color: var(--text-muted);
            font-size: var(--text-sm);
        }

        .history-empty svg {
            width: 32px;
            height: 32px;
            margin-bottom: var(--space-2);
            opacity: 0.5;
        }

        /* Legacy persona list styles - keeping for backward compatibility */
        .personas-list {
            flex: 1;
            overflow-y: auto;
            padding: var(--space-2);
        }

        .persona-item {
            display: flex;
            align-items: center;
            gap: var(--space-3);
            padding: var(--space-3);
            border-radius: var(--radius-md);
            cursor: pointer;
            transition: all var(--transition-fast);
            margin-bottom: var(--space-1);
        }

        .persona-item:hover {
            background: var(--bg-secondary);
        }

        .persona-item.active {
            background: var(--bg-tertiary);
        }

        .persona-avatar-sm {
            width: 36px;
            height: 36px;
            border-radius: 50%;
            background: var(--bg-tertiary);
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: var(--font-semibold);
            flex-shrink: 0;
        }

        .persona-item.active .persona-avatar-sm {
            background: var(--text-primary);
            color: var(--bg-primary);
        }

        .persona-details {
            flex: 1;
            min-width: 0;
        }

        .persona-name {
            font-weight: var(--font-medium);
            font-size: var(--text-sm);
            color: var(--text-primary);
        }

        .persona-category {
            font-size: var(--text-xs);
            color: var(--text-muted);
        }

        .sidebar-footer {
            padding: var(--space-3);
            border-top: 1px solid var(--border-subtle);
        }

        /* Delete Confirmation Modal */
        .delete-modal-overlay {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: var(--z-modal);
            opacity: 0;
            visibility: hidden;
            transition: all var(--transition-normal);
        }

        .delete-modal-overlay.show {
            opacity: 1;
            visibility: visible;
        }

        .delete-modal {
            background: var(--bg-primary);
            border-radius: var(--radius-lg);
            padding: var(--space-6);
            max-width: 400px;
            width: 90%;
            text-align: center;
        }

        .delete-modal h3 {
            margin: 0 0 var(--space-3) 0;
            font-size: var(--text-lg);
        }

        .delete-modal p {
            color: var(--text-muted);
            margin-bottom: var(--space-4);
        }

        .delete-modal-actions {
            display: flex;
            gap: var(--space-3);
            justify-content: center;
        }

        /* Main Chat Area */
        .chat-main {
            flex: 1;
            display: flex;
            flex-direction: column;
            min-width: 0;
            position: relative;
        }

        .chat-main.drag-active::after {
            content: 'Drop file here';
            position: absolute;
            inset: 0;
            background: rgba(59, 130, 246, 0.1);
            border: 3px dashed var(--pop-primary);
            border-radius: var(--radius-lg);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.25rem;
            font-weight: 500;
            color: var(--pop-primary);
            z-index: 100;
            pointer-events: none;
        }

        .chat-header {
            padding: var(--space-4);
            border-bottom: 1px solid var(--border-subtle);
            display: flex;
            align-items: center;
            justify-content: space-between;
            background: var(--bg-primary);
        }

        .chat-header-left {
            display: flex;
            align-items: center;
            gap: var(--space-3);
        }

        .sidebar-toggle {
            padding: var(--space-2);
            background: transparent;
            border: none;
            color: var(--text-secondary);
            cursor: pointer;
            border-radius: var(--radius-md);
            transition: all var(--transition-fast);
        }

        .sidebar-toggle:hover {
            background: var(--bg-secondary);
            color: var(--text-primary);
        }

        .chat-title {
            font-weight: var(--font-semibold);
        }

        .chat-header-actions {
            display: flex;
            align-items: center;
            gap: var(--space-2);
        }

        /* Export Dropdown */
        .export-dropdown {
            position: relative;
            display: inline-block;
        }

        .export-dropdown-content {
            display: none;
            position: absolute;
            right: 0;
            top: 100%;
            min-width: 200px;
            background: var(--bg-primary);
            border: 1px solid var(--border-color);
            border-radius: var(--radius-md);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            z-index: var(--z-dropdown);
            padding: var(--space-2) 0;
            margin-top: var(--space-1);
        }

        .export-dropdown-content.show {
            display: block;
        }

        .export-dropdown-header {
            padding: var(--space-2) var(--space-3);
            font-size: var(--text-xs);
            font-weight: var(--font-semibold);
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        .export-dropdown-item {
            display: flex;
            align-items: center;
            gap: var(--space-2);
            padding: var(--space-2) var(--space-3);
            color: var(--text-primary);
            text-decoration: none;
            font-size: var(--text-sm);
            cursor: pointer;
            transition: background var(--transition-fast);
            border: none;
            background: none;
            width: 100%;
            text-align: left;
        }

        .export-dropdown-item:hover {
            background: var(--bg-secondary);
        }

        .export-dropdown-item .export-icon {
            width: 16px;
            height: 16px;
            color: var(--text-muted);
        }

        .export-dropdown-item .export-label {
            flex: 1;
        }

        .export-dropdown-item .export-ext {
            font-size: var(--text-xs);
            color: var(--text-muted);
        }

        .export-dropdown-divider {
            height: 1px;
            background: var(--border-subtle);
            margin: var(--space-2) 0;
        }

        .format-btn {
            padding: 4px 8px;
            font-size: var(--text-xs);
            border: 1px solid var(--border-color);
            border-radius: var(--radius-sm);
            background: var(--bg-secondary);
            color: var(--text-secondary);
            cursor: pointer;
            transition: all var(--transition-fast);
        }

        .format-btn:hover {
            border-color: var(--text-primary);
            color: var(--text-primary);
        }

        .format-btn.active {
            background: var(--text-primary);
            color: var(--bg-primary);
            border-color: var(--text-primary);
        }

        .export-dropdown-item.loading {
            opacity: 0.5;
            pointer-events: none;
        }

        .export-dropdown-item.loading::after {
            content: " ...";
        }

        /* LLM Info Banner */
        .llm-info-banner {
            display: none;
            padding: var(--space-2) var(--space-4);
            background: rgba(59, 130, 246, 0.1);
            border-bottom: 1px solid rgba(59, 130, 246, 0.2);
            color: var(--text-muted);
            font-size: var(--text-sm);
            text-align: center;
        }

        .llm-info-banner.warning {
            background: rgba(234, 179, 8, 0.1);
            border-color: rgba(234, 179, 8, 0.2);
            color: #ca8a04;
        }

        .llm-info-banner.show {
            display: block;
        }

        .llm-info-banner a {
            color: inherit;
            text-decoration: underline;
            margin-left: var(--space-2);
        }

        .llm-banner-dismiss {
            background: none;
            border: none;
            color: inherit;
            font-size: 1.1rem;
            cursor: pointer;
            margin-left: var(--space-3);
            opacity: 0.7;
            padding: 0 var(--space-1);
            line-height: 1;
        }

        .llm-banner-dismiss:hover {
            opacity: 1;
        }

        /* Messages Area */
        .chat-messages {
            flex: 1;
            overflow-y: auto;
            padding: var(--space-4);
            background: var(--bg-secondary);
        }

        .message {
            margin-bottom: var(--space-4);
            max-width: 80%;
        }

        .message.user {
            margin-left: auto;
        }

        .message-content {
            padding: var(--space-3) var(--space-4);
            border-radius: var(--radius-lg);
            line-height: 1.5;
        }

        .message.user .message-content {
            background: var(--text-primary);
            color: var(--bg-primary);
            border-bottom-right-radius: var(--radius-sm);
        }

        /* Dark mode: Use a darker background for user messages for better visual comfort */
        .theme-dark .message.user .message-content {
            background: var(--bg-tertiary);
            color: var(--text-primary);
            border: 1px solid var(--border-color);
        }

        /* Edit persona link styling */
        .edit-persona-link {
            opacity: 0.6;
            transition: opacity var(--transition-fast);
        }

        .edit-persona-link:hover {
            opacity: 1;
        }

        .message.assistant .message-content {
            background: var(--bg-primary);
            color: var(--text-primary);
            border: 1px solid var(--border-color);
            border-bottom-left-radius: var(--radius-sm);
        }

        .message-sender {
            font-size: var(--text-xs);
            color: var(--text-muted);
            margin-bottom: var(--space-1);
        }

        .message.user .message-sender {
            text-align: right;
        }

        /* Chat Input */
        .chat-input-area {
            padding: var(--space-4);
            background: var(--bg-primary);
            border-top: 1px solid var(--border-subtle);
        }

        .file-upload-zone {
            border: 2px dashed var(--border-color);
            border-radius: var(--radius-md);
            padding: var(--space-4);
            text-align: center;
            margin-bottom: var(--space-3);
            display: none;
            transition: all var(--transition-fast);
        }

        .file-upload-zone.active {
            display: block;
        }

        .file-upload-zone.dragover {
            border-color: var(--pop-primary);
            background: rgba(59, 130, 246, 0.05);
        }

        .file-upload-zone input[type="file"] {
            display: none;
        }

        .uploaded-file {
            display: flex;
            align-items: center;
            gap: var(--space-2);
            padding: var(--space-2) var(--space-3);
            background: var(--bg-secondary);
            border-radius: var(--radius-md);
            margin-bottom: var(--space-3);
            font-size: var(--text-sm);
        }

        .uploaded-file .remove-file {
            margin-left: auto;
            cursor: pointer;
            color: var(--text-muted);
        }

        .uploaded-file .remove-file:hover {
            color: var(--pop-danger);
        }

        .chat-input-wrapper {
            display: flex;
            gap: var(--space-2);
        }

        .chat-input {
            flex: 1;
            padding: var(--space-3) var(--space-4);
            border: 1px solid var(--border-color);
            border-radius: var(--radius-lg);
            background: var(--bg-primary);
            color: var(--text-primary);
            font-size: var(--text-base);
            resize: none;
        }

        .chat-input:focus {
            outline: none;
            border-color: var(--text-primary);
        }

        .chat-input:disabled {
            background: var(--bg-secondary);
            cursor: not-allowed;
        }

        .send-btn {
            padding: var(--space-3) var(--space-4);
            background: var(--text-primary);
            color: var(--bg-primary);
            border: none;
            border-radius: var(--radius-lg);
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: var(--space-2);
            transition: all var(--transition-fast);
        }

        .send-btn:hover:not(:disabled) {
            opacity: 0.9;
        }

        .send-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        /* Document Panel */
        .document-panel {
            position: fixed;
            top: 0;
            right: -400px;
            width: 400px;
            height: 100vh;
            background: var(--bg-primary);
            border-left: 1px solid var(--border-color);
            transition: right var(--transition-normal);
            z-index: var(--z-modal);
            display: flex;
            flex-direction: column;
        }

        .document-panel.open {
            right: 0;
        }

        .document-panel-header {
            padding: var(--space-4);
            border-bottom: 1px solid var(--border-subtle);
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .document-panel-body {
            flex: 1;
            overflow-y: auto;
            padding: var(--space-4);
        }

        .document-item {
            padding: var(--space-3);
            border: 1px solid var(--border-color);
            border-radius: var(--radius-md);
            margin-bottom: var(--space-2);
        }

        .document-item:hover {
            border-color: var(--text-muted);
        }

        .panel-overlay {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.3);
            z-index: calc(var(--z-modal) - 1);
            opacity: 0;
            visibility: hidden;
            transition: all var(--transition-normal);
        }

        .panel-overlay.show {
            opacity: 1;
            visibility: visible;
        }

        /* Source Citations */
        .source-citation {
            display: inline-flex;
            align-items: center;
            gap: var(--space-1);
            padding: var(--space-1) var(--space-2);
            background: var(--bg-tertiary);
            border-radius: var(--radius-sm);
            font-size: var(--text-xs);
            color: var(--text-secondary);
            cursor: pointer;
            margin-right: var(--space-1);
            margin-bottom: var(--space-1);
        }

        .source-citation:hover {
            background: var(--pop-primary);
            color: white;
        }

        .document-analysis {
            margin-top: var(--space-3);
            padding: var(--space-3);
            background: var(--bg-secondary);
            border-left: 3px solid var(--pop-primary);
            border-radius: 0 var(--radius-md) var(--radius-md) 0;
            font-size: var(--text-sm);
        }

        /* Processing Status */
        .processing-status {
            display: none;
            align-items: center;
            gap: var(--space-2);
            padding: var(--space-2) var(--space-3);
            background: var(--bg-secondary);
            border-radius: var(--radius-md);
            margin-bottom: var(--space-3);
            font-size: var(--text-sm);
            color: var(--text-secondary);
        }

        .processing-status.show {
            display: flex;
        }

        /* Typing indicator */
        .typing-indicator {
            display: flex;
            gap: 4px;
            padding: var(--space-3) var(--space-4);
            background: var(--bg-primary);
            border: 1px solid var(--border-color);
            border-radius: var(--radius-lg);
            width: fit-content;
        }

        .typing-indicator span {
            width: 8px;
            height: 8px;
            background: var(--text-muted);
            border-radius: 50%;
            animation: typing 1.4s infinite ease-in-out both;
        }

        .typing-indicator span:nth-child(1) { animation-delay: -0.32s; }
        .typing-indicator span:nth-child(2) { animation-delay: -0.16s; }

        @keyframes typing {
            0%, 80%, 100% { transform: scale(0.6); opacity: 0.5; }
            40% { transform: scale(1); opacity: 1; }
        }

        /* Mobile sidebar backdrop */
        .sidebar-backdrop {
            display: none;
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.5);
            z-index: calc(var(--z-modal) - 1);
            opacity: 0;
            transition: opacity var(--transition-normal);
        }

        .sidebar-backdrop.show {
            opacity: 1;
        }

        /* Mobile hamburger button */
        .mobile-menu-btn {
            display: none;
            align-items: center;
            justify-content: center;
            width: 40px;
            height: 40px;
            background: transparent;
            border: 1px solid var(--border-color);
            border-radius: var(--radius-md);
            cursor: pointer;
            color: var(--text-primary);
        }

        .mobile-menu-btn svg {
            width: 20px;
            height: 20px;
            stroke: currentColor;
        }

        /* Mobile */
        @media (max-width: 768px) {
            .chat-sidebar {
                position: fixed;
                left: 0;
                top: 0;
                height: 100%;
                z-index: var(--z-modal);
                transform: translateX(0);
                transition: transform var(--transition-normal);
            }

            .chat-sidebar.collapsed {
                transform: translateX(-100%);
            }

            .sidebar-backdrop {
                display: block;
            }

            .mobile-menu-btn {
                display: flex;
            }

            .message {
                max-width: 90%;
            }

            .chat-header {
                padding: var(--space-3);
            }

            .chat-input-area {
                padding: var(--space-3);
            }

            .chat-messages {
                padding: var(--space-3);
            }

            /* Touch-friendly persona items */
            .persona-item {
                min-height: 56px;
                padding: var(--space-4);
            }

            /* Hide sidebar toggle text on mobile */
            .sidebar-toggle span {
                display: none;
            }
        }

        @media (max-width: 480px) {
            .message {
                max-width: 95%;
            }

            .chat-header-actions {
                gap: var(--space-1);
            }

            .btn-sm {
                padding: var(--space-2);
            }
        }

        /* Empty state */
        .empty-chat {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            text-align: center;
            padding: var(--space-8);
            color: var(--text-muted);
        }

        .empty-chat svg {
            width: 64px;
            height: 64px;
            stroke: var(--text-muted);
            margin-bottom: var(--space-4);
        }
    </style>
</head>
<body>
    <!-- Mobile sidebar backdrop -->
    <div class="sidebar-backdrop" id="sidebarBackdrop"></div>

    <div class="chat-layout">
        <!-- Sidebar -->
        <aside class="chat-sidebar" id="chatSidebar">
            <div class="sidebar-header">
                <a href="/dashboard" style="display: flex; align-items: center; gap: 0.5rem;">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" style="width: 20px; height: 20px;">
                        <path d="M12 5c.67 0 1.35.09 2 .26 1.78-2 5.03-2.84 6.42-2.26 1.4.58-.42 7-.42 7 .57 1.07 1 2.24 1 3.44C21 17.9 16.97 21 12 21s-9-3-9-7.56c0-1.25.5-2.4 1-3.44 0 0-1.89-6.42-.5-7 1.39-.58 4.72.23 6.5 2.23A9.04 9.04 0 0 1 12 5Z"/>
                        <path d="M8 14v.5"/><path d="M16 14v.5"/><path d="M11.25 16.25h1.5L12 17l-.75-.75Z"/>
                    </svg>
                    MinouChat
                </a>
                <button class="theme-toggle" title="Toggle theme" aria-label="Toggle dark/light theme">
                    <svg class="icon-sun" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
                        <circle cx="12" cy="12" r="5"/>
                        <line x1="12" y1="1" x2="12" y2="3"/>
                        <line x1="12" y1="21" x2="12" y2="23"/>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/>
                        <line x1="1" y1="12" x2="3" y2="12"/>
                        <line x1="21" y1="12" x2="23" y2="12"/>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/>
                    </svg>
                    <svg class="icon-moon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"/>
                    </svg>
                </button>
            </div>

            <!-- Persona Dropdown -->
            <div class="persona-dropdown-wrapper">
                <select class="persona-dropdown" id="personaDropdown">
                    <option value="">Select a persona...</option>
                    {% for persona in personas %}
                    <option value="{{ persona.id }}"
                            data-name="{{ persona.name }}"
                            data-category="{{ persona.category or 'General' }}"
                            data-hide-category="{{ 'true' if persona.hide_category else 'false' }}">
                        {% if persona.hide_category %}
                        {{ persona.name }}
                        {% else %}
                        {{ persona.name }} ({{ persona.category or 'General' }})
                        {% endif %}
                    </option>
                    {% endfor %}
                </select>
            </div>

            <!-- Sidebar Documents Section -->
            <div class="sidebar-documents" id="sidebarDocuments" style="display: none;">
                <!-- Todo List (for non-Coach personas) -->
                <div class="sidebar-todo-section" id="todoSection" style="display: none;">
                    <div class="sidebar-section-header">
                        <h4>
                            <i data-lucide="check-square" style="width: 16px; height: 16px;"></i>
                            Todo List
                        </h4>
                        <div style="display: flex; gap: 4px;">
                            <button class="btn btn-ghost btn-sm" onclick="exportTodos()" title="Export/Print">
                                <i data-lucide="printer" style="width: 14px; height: 14px;"></i>
                            </button>
                            <button class="btn btn-ghost btn-sm" onclick="addTodoInline()" title="Add todo">
                                <i data-lucide="plus" style="width: 14px; height: 14px;"></i>
                            </button>
                        </div>
                    </div>
                    <div class="todo-list" id="todoList">
                        <p class="text-muted text-sm text-center" style="padding: var(--space-2);">Loading...</p>
                    </div>
                    <div class="todo-add-form" id="todoAddForm" style="display: none;">
                        <input type="text" class="form-input form-input-sm"
                               placeholder="Add a task..." id="newTodoInput"
                               onkeypress="if(event.key==='Enter') saveTodo()">
                        <div class="todo-add-actions">
                            <button class="btn btn-sm btn-primary" onclick="saveTodo()">Add</button>
                            <button class="btn btn-sm btn-ghost" onclick="cancelAddTodo()">Cancel</button>
                        </div>
                    </div>
                </div>

                <!-- Goals Section -->
                <div class="sidebar-goals-section" id="goalsSection" style="display: none;">
                    <div class="sidebar-section-header">
                        <h4>
                            <i data-lucide="target" style="width: 16px; height: 16px;"></i>
                            Goals
                        </h4>
                        <button class="btn btn-ghost btn-sm" onclick="showAddGoalModal()" title="Add goal">
                            <i data-lucide="plus" style="width: 14px; height: 14px;"></i>
                        </button>
                    </div>
                    <div class="goals-list" id="goalsList">
                        <p class="text-muted text-sm text-center" style="padding: var(--space-2);">Loading...</p>
                    </div>
                </div>

                <!-- Habits Section -->
                <div class="sidebar-habits-section" id="habitsSection" style="display: none;">
                    <div class="sidebar-section-header">
                        <h4>
                            <i data-lucide="repeat" style="width: 16px; height: 16px;"></i>
                            Habits
                        </h4>
                        <button class="btn btn-ghost btn-sm" onclick="showAddHabitModal()" title="Add habit">
                            <i data-lucide="plus" style="width: 14px; height: 14px;"></i>
                        </button>
                    </div>
                    <div class="habits-list" id="habitsList">
                        <p class="text-muted text-sm text-center" style="padding: var(--space-2);">Loading...</p>
                    </div>
                </div>

                <!-- Life Areas Scorecard (for Coach personas) -->
                <div class="sidebar-life-areas" id="lifeAreasSection" style="display: none;">
                    <div class="sidebar-section-header">
                        <h4>
                            <i data-lucide="pie-chart" style="width: 16px; height: 16px;"></i>
                            Life Areas
                        </h4>
                        <span class="life-areas-average" id="lifeAreasAverage">--</span>
                    </div>
                    <div class="life-areas-grid" id="lifeAreasGrid">
                        <p class="text-muted text-sm text-center" style="padding: var(--space-2); grid-column: 1/-1;">Loading...</p>
                    </div>
                </div>
            </div>

            <!-- New Chat Button -->
            <div class="new-chat-wrapper">
                <button class="new-chat-btn" id="newChatBtn" onclick="startNewChat()">
                    <i data-lucide="plus" style="width: 16px; height: 16px;"></i>
                    New Chat
                </button>
            </div>

            <!-- Conversation History -->
            <div class="conversation-history" id="conversationHistory">
                <div class="history-empty">
                    <i data-lucide="message-square" style="width: 32px; height: 32px;"></i>
                    <p>Select a persona to see your chat history</p>
                </div>
            </div>

            <div class="sidebar-footer">
                <a href="/personas" class="btn btn-secondary" style="width: 100%;">
                    <i data-lucide="user-plus" style="width: 16px; height: 16px;"></i>
                    Manage Personas
                </a>
            </div>
        </aside>

        <!-- Delete Confirmation Modal -->
        <div class="delete-modal-overlay" id="deleteModalOverlay">
            <div class="delete-modal">
                <h3>Delete Conversation?</h3>
                <p>This will permanently delete this conversation and all its messages.</p>
                <div class="delete-modal-actions">
                    <button class="btn btn-secondary" onclick="closeDeleteModal()">Cancel</button>
                    <button class="btn btn-danger" onclick="confirmDeleteConversation()">Delete</button>
                </div>
            </div>
        </div>

        <!-- Main Chat -->
        <main class="chat-main">
            <header class="chat-header">
                <div class="chat-header-left">
                    <button class="sidebar-toggle" onclick="toggleSidebar()" title="Show/hide persona list">
                        <i data-lucide="panel-left" style="width: 20px; height: 20px;"></i>
                    </button>
                    <span class="chat-title" id="currentPersona">{{ active_persona or 'Select a persona' }}</span>
                    <a href="#" class="btn btn-ghost btn-sm edit-persona-link" id="editPersonaLink" style="display: none;" title="Edit this persona's settings">
                        <i data-lucide="settings" style="width: 16px; height: 16px;"></i>
                    </a>
                </div>

                <div class="chat-header-actions">
                    <button class="btn btn-ghost" onclick="toggleFileUpload()" title="Attach a file to include in the conversation (PDF, Word, Text, etc.)">
                        <i data-lucide="paperclip" style="width: 18px; height: 18px;"></i>
                    </button>
                    <button class="btn btn-ghost" onclick="toggleDocumentPanel()" title="View and manage uploaded documents for this conversation">
                        <i data-lucide="file-text" style="width: 18px; height: 18px;"></i>
                    </button>
                    <!-- Export Dropdown -->
                    <div class="export-dropdown" id="exportDropdown">
                        <button class="btn btn-ghost" onclick="toggleExportDropdown(event)" title="Generate document from conversation">
                            <i data-lucide="file-output" style="width: 18px; height: 18px;"></i>
                        </button>
                        <div class="export-dropdown-content" id="exportDropdownContent">
                            <!-- Basic Export Options -->
                            <div class="export-dropdown-header">Quick Export</div>
                            <button class="export-dropdown-item" onclick="exportConversation('pdf')">
                                <i data-lucide="file" class="export-icon"></i>
                                <span class="export-label">Full Transcript (PDF)</span>
                                <span class="export-ext">.pdf</span>
                            </button>
                            <button class="export-dropdown-item" onclick="exportConversation('md')">
                                <i data-lucide="file-code" class="export-icon"></i>
                                <span class="export-label">Full Transcript (Markdown)</span>
                                <span class="export-ext">.md</span>
                            </button>

                            <!-- Dynamic Document Types (loaded based on character category) -->
                            <div id="documentTypesSection" style="display: none;">
                                <div class="export-dropdown-divider"></div>
                                <div class="export-dropdown-header" id="documentTypesHeader">Generate Document</div>
                                <div id="documentTypesList">
                                    <!-- Populated dynamically by JavaScript -->
                                </div>
                            </div>

                            <!-- Format Selection Modal Trigger -->
                            <div class="export-dropdown-divider"></div>
                            <div class="export-dropdown-header">Output Format</div>
                            <div style="display: flex; gap: 4px; padding: 4px 12px;">
                                <button class="format-btn active" data-format="pdf" title="PDF">PDF</button>
                                <button class="format-btn" data-format="docx" title="Word">DOCX</button>
                                <button class="format-btn" data-format="md" title="Markdown">MD</button>
                                <button class="format-btn" data-format="txt" title="Plain Text">TXT</button>
                            </div>
                        </div>
                    </div>
                    <button class="btn btn-ghost" onclick="clearChat()" title="Clear all messages in this chat session">
                        <i data-lucide="trash-2" style="width: 18px; height: 18px;"></i>
                    </button>
                    <a href="/dashboard" class="btn btn-ghost" title="Return to the main dashboard">
                        <i data-lucide="layout-dashboard" style="width: 18px; height: 18px;"></i>
                    </a>
                </div>
            </header>

            <!-- LLM Info Banner (shown when using system default LLM) -->
            <div class="llm-info-banner" id="llmInfoBanner">
                <span id="llmInfoText">Using system default AI</span>
                <a id="llmBannerLink" href="/settings" title="Configure model">Configure</a>
                <button id="llmBannerDismiss" class="llm-banner-dismiss" title="Keep default" aria-label="Dismiss">&times;</button>
            </div>

            <div class="chat-messages" id="chatContainer">
                <!-- Messages will be added here -->
            </div>

            <div class="chat-input-area">
                <!-- File Upload Zone -->
                <div class="file-upload-zone" id="fileUploadArea">
                    <i data-lucide="upload-cloud" style="width: 32px; height: 32px; color: var(--text-muted);"></i>
                    <p class="text-muted text-sm" style="margin: var(--space-2) 0;">Drop files here or click to browse</p>
                    <input type="file" id="fileInput" accept=".pdf,.doc,.docx,.txt,.md,.csv,.xlsx,.xls" multiple>
                    <button type="button" class="btn btn-secondary btn-sm" onclick="document.getElementById('fileInput').click()">
                        Choose File
                    </button>
                    <p class="text-muted text-xs" style="margin-top: var(--space-2);">PDF, Word, Text, Markdown, CSV, Excel</p>
                </div>

                <!-- Processing Status -->
                <div class="processing-status" id="processingStatus">
                    <span class="spinner spinner-sm"></span>
                    Processing document...
                </div>

                <!-- Uploaded File Info -->
                <div id="uploadedFileInfo"></div>

                <!-- Chat Input -->
                <form id="chatForm">
                    <div class="chat-input-wrapper">
                        <input type="text" class="chat-input" id="messageInput"
                               placeholder="Type your message..." disabled autocomplete="off">
                        <button type="submit" class="send-btn" disabled>
                            <i data-lucide="send" style="width: 18px; height: 18px;"></i>
                            Send
                        </button>
                    </div>
                </form>
            </div>
        </main>
    </div>

    <!-- Document Panel -->
    <div class="panel-overlay" id="documentOverlay" onclick="closeDocumentPanel()"></div>
    <aside class="document-panel" id="documentPanel">
        <div class="document-panel-header">
            <h3 style="font-size: var(--text-base); margin: 0;">Documents</h3>
            <button class="btn btn-ghost" onclick="closeDocumentPanel()">
                <i data-lucide="x" style="width: 20px; height: 20px;"></i>
            </button>
        </div>
        <div class="document-panel-body" id="documentList">
            <p class="text-muted text-center">Loading documents...</p>
        </div>
    </aside>

    <script src="{{ url_for('static', path='js/theme.js') }}"></script>

    {% if clerk_configured %}
    <!-- Clerk SDK for session token management -->
    <script
        async
        crossorigin="anonymous"
        data-clerk-publishable-key="{{ clerk_publishable_key }}"
        src="https://cdn.jsdelivr.net/npm/@clerk/clerk-js@latest/dist/clerk.browser.js"
        type="text/javascript"
    ></script>
    {% endif %}

    <script>
        // Wait for Clerk to be ready
        let clerkReady = false;
        let clerkReadyPromise = new Promise((resolve) => {
            if (window.Clerk) {
                window.Clerk.load().then(() => {
                    clerkReady = true;
                    resolve();
                }).catch(() => resolve());
            } else {
                // Wait for Clerk script to load
                const checkClerk = setInterval(() => {
                    if (window.Clerk) {
                        clearInterval(checkClerk);
                        window.Clerk.load().then(() => {
                            clerkReady = true;
                            resolve();
                        }).catch(() => resolve());
                    }
                }, 100);
                // Timeout after 5 seconds
                setTimeout(() => {
                    clearInterval(checkClerk);
                    resolve();
                }, 5000);
            }
        });

        // Get fresh token from Clerk
        async function getFreshToken() {
            if (window.Clerk && window.Clerk.session) {
                try {
                    // Force refresh to get a new token
                    return await window.Clerk.session.getToken();
                } catch (e) {
                    console.warn('Could not get Clerk token:', e);
                    return null;
                }
            }
            return null;
        }

        // Authenticated fetch helper - refreshes token if needed and retries on 401
        async function authFetch(url, options = {}, retried = false) {
            // Wait for Clerk to be ready (with timeout)
            await Promise.race([clerkReadyPromise, new Promise(r => setTimeout(r, 2000))]);

            // Get a fresh token from Clerk if available
            const token = await getFreshToken();
            if (token) {
                options.headers = options.headers || {};
                options.headers['Authorization'] = `Bearer ${token}`;
            }

            const response = await fetch(url, options);

            // If 401 and we haven't retried yet, get a fresh token and retry
            if (response.status === 401 && !retried) {
                // Check if token was specifically expired
                const authError = response.headers.get('X-Auth-Error');
                console.log('Got 401, error type:', authError, '- refreshing token and retrying...');

                // Touch the session to ensure token refresh
                if (window.Clerk && window.Clerk.session) {
                    try {
                        await window.Clerk.session.touch();
                    } catch (e) {
                        console.warn('Session touch failed:', e);
                        // If touch fails, session might be invalid - redirect to login
                        if (authError !== 'token_expired') {
                            window.location.href = '/auth/login';
                            return response;
                        }
                    }
                }
                // Retry with fresh token
                return authFetch(url, { ...options, headers: {} }, true);
            }

            // If still 401 after retry, redirect to login
            if (response.status === 401 && retried) {
                console.error('Authentication failed after retry, redirecting to login');
                window.location.href = '/auth/login';
            }

            return response;
        }

        // Proactive token refresh - keep the session alive
        let tokenRefreshInterval = null;
        function startTokenRefresh() {
            if (tokenRefreshInterval) return;
            // Refresh every 45 seconds (Clerk tokens expire at 60s)
            tokenRefreshInterval = setInterval(async () => {
                if (window.Clerk && window.Clerk.session) {
                    try {
                        await window.Clerk.session.touch();
                        console.log('Session refreshed proactively');
                    } catch (e) {
                        console.warn('Proactive session refresh failed:', e);
                    }
                }
            }, 45000);
        }

        // Start proactive refresh when Clerk is ready
        clerkReadyPromise.then(() => {
            if (window.Clerk && window.Clerk.session) {
                startTokenRefresh();
            }
        });

        // Initialize Lucide
        document.addEventListener('DOMContentLoaded', () => {
            if (typeof lucide !== 'undefined') lucide.createIcons();
        });

        // State
        let currentCharacterId = new URLSearchParams(window.location.search).get('character_id');
        let currentPersona = '';
        let currentSessionId = localStorage.getItem('currentSessionId');
        let chatHistory = [];
        let selectedFile = null;
        // Initialize sidebar state based on screen size
        let sidebarCollapsed = window.innerWidth <= 768;
        let documentPanelOpen = false;
        let conversationToDelete = null;  // Track which conversation is pending deletion

        // Apply initial collapsed state for mobile
        if (sidebarCollapsed) {
            document.getElementById('chatSidebar').classList.add('collapsed');
        }

        // Initialize if character_id present
        if (currentCharacterId) {
            authFetch(`/api/characters/${currentCharacterId}`)
                .then(r => r.json())
                .then(data => {
                    if (data && !data.error) {
                        currentPersona = data.name;
                        document.getElementById('currentPersona').textContent = data.name;
                        updateEditPersonaLink(currentCharacterId);

                        // Update character category for export document types
                        updateCharacterCategory(data.category);

                        // Update sidebar documents (todos for Assistant, life areas for Coach)
                        updateSidebarDocuments(data.category);

                        enableChat();

                        // Set dropdown to this character
                        const dropdown = document.getElementById('personaDropdown');
                        dropdown.value = currentCharacterId;

                        // Load conversation history for this character
                        loadConversationHistory(currentCharacterId);

                        if (currentSessionId) {
                            loadExistingConversation();
                        } else {
                            // Fetch personalized greeting
                            showPersonalizedGreeting(currentCharacterId, data.name);
                        }
                    }
                });
        }

        // Fetch and display a personalized greeting
        async function showPersonalizedGreeting(characterId, fallbackName) {
            try {
                const response = await authFetch(`/api/characters/${characterId}/greeting`);
                if (response.ok) {
                    const data = await response.json();
                    addMessage('assistant', data.greeting);
                } else {
                    // Fallback to simple greeting
                    addMessage('assistant', `Hi there! I'm ${fallbackName}. What's on your mind?`);
                }
            } catch (e) {
                // Fallback on error
                addMessage('assistant', `Hi there! I'm ${fallbackName}. What's on your mind?`);
            }
        }

        // Persona selection via dropdown
        document.getElementById('personaDropdown').addEventListener('change', function() {
            const selectedOption = this.options[this.selectedIndex];
            if (this.value) {
                selectPersona(selectedOption.dataset.name, this.value, selectedOption.dataset.category);
            }
        });

        function selectPersona(name, characterId, category) {
            currentPersona = name;
            currentCharacterId = characterId;
            currentSessionId = null;  // Clear session for new persona
            localStorage.removeItem('currentSessionId');

            document.getElementById('currentPersona').textContent = name;

            // Show edit persona link
            updateEditPersonaLink(characterId);

            // Update character category for export document types
            updateCharacterCategory(category);

            // Update sidebar documents (todos for Assistant, life areas for Coach)
            updateSidebarDocuments(category);

            // Hide the LLM banner until we get a chat response with LLM info
            resetLLMBannerDismiss();

            // Load conversation history for this persona
            loadConversationHistory(characterId);

            enableChat();
            clearChat();
            // Use personalized greeting instead of generic one
            showPersonalizedGreeting(characterId, name);

            // Update URL without reloading
            const url = new URL(window.location);
            url.searchParams.set('character_id', characterId);
            window.history.pushState({}, '', url);
        }

        // Start a new chat (clear current conversation)
        function startNewChat() {
            if (!currentCharacterId) {
                showToast('Please select a persona first', 'error');
                return;
            }

            currentSessionId = null;
            localStorage.removeItem('currentSessionId');
            clearChat();
            showPersonalizedGreeting(currentCharacterId, currentPersona);

            // Update active state in conversation list
            document.querySelectorAll('.conversation-item').forEach(item => {
                item.classList.remove('active');
            });

            showToast('Started new conversation', 'success');
        }

        // Load conversation history for a character
        async function loadConversationHistory(characterId) {
            const container = document.getElementById('conversationHistory');
            container.innerHTML = '<div class="history-empty"><span class="spinner spinner-sm"></span><p>Loading...</p></div>';

            try {
                const response = await authFetch(`/api/conversations/character/${characterId}`);
                if (!response.ok) {
                    throw new Error('Failed to load conversations');
                }

                const data = await response.json();
                renderConversationHistory(data.groups);
            } catch (e) {
                console.error('Error loading conversation history:', e);
                container.innerHTML = `
                    <div class="history-empty">
                        <i data-lucide="alert-circle" style="width: 32px; height: 32px;"></i>
                        <p>Could not load history</p>
                    </div>
                `;
                lucide.createIcons();
            }
        }

        // Render conversation history grouped by date
        function renderConversationHistory(groups) {
            const container = document.getElementById('conversationHistory');

            // Check if there are any conversations
            const hasConversations = Object.values(groups).some(g => g.length > 0);

            if (!hasConversations) {
                container.innerHTML = `
                    <div class="history-empty">
                        <i data-lucide="message-square" style="width: 32px; height: 32px;"></i>
                        <p>No conversations yet.<br>Start chatting!</p>
                    </div>
                `;
                lucide.createIcons();
                return;
            }

            const groupLabels = {
                today: 'Today',
                yesterday: 'Yesterday',
                previous_7_days: 'Previous 7 Days',
                older: 'Older'
            };

            let html = '';
            for (const [groupKey, conversations] of Object.entries(groups)) {
                if (conversations.length === 0) continue;

                html += `<div class="history-group">`;
                html += `<div class="history-group-label">${groupLabels[groupKey]}</div>`;

                for (const conv of conversations) {
                    const isActive = conv.id === currentSessionId ? 'active' : '';
                    html += `
                        <div class="conversation-item ${isActive}"
                             data-session-id="${conv.id}"
                             onclick="loadConversation('${conv.id}')">
                            <i data-lucide="message-square" class="conversation-item-icon"></i>
                            <span class="conversation-item-title">${escapeHtml(conv.title)}</span>
                            <button class="conversation-item-delete"
                                    onclick="event.stopPropagation(); showDeleteModal('${conv.id}')"
                                    title="Delete conversation">
                                <i data-lucide="trash-2" style="width: 14px; height: 14px;"></i>
                            </button>
                        </div>
                    `;
                }
                html += `</div>`;
            }

            container.innerHTML = html;
            lucide.createIcons();
        }

        // Load a specific conversation
        async function loadConversation(sessionId) {
            if (!sessionId) return;

            // Update active state
            document.querySelectorAll('.conversation-item').forEach(item => {
                item.classList.toggle('active', item.dataset.sessionId === sessionId);
            });

            currentSessionId = sessionId;
            localStorage.setItem('currentSessionId', sessionId);

            // Load conversation history
            try {
                const response = await authFetch(`/api/conversations/${sessionId}/history`);
                if (!response.ok) {
                    throw new Error('Failed to load conversation');
                }

                const data = await response.json();
                clearChat();

                if (data.history && data.history.length > 0) {
                    data.history.forEach(msg => addMessage(msg.role, msg.content));
                } else {
                    showPersonalizedGreeting(currentCharacterId, currentPersona);
                }
            } catch (e) {
                console.error('Error loading conversation:', e);
                showToast('Could not load conversation', 'error');
            }
        }

        // Delete conversation modal
        function showDeleteModal(sessionId) {
            conversationToDelete = sessionId;
            document.getElementById('deleteModalOverlay').classList.add('show');
        }

        function closeDeleteModal() {
            conversationToDelete = null;
            document.getElementById('deleteModalOverlay').classList.remove('show');
        }

        async function confirmDeleteConversation() {
            if (!conversationToDelete) return;

            try {
                const response = await authFetch(`/api/conversations/${conversationToDelete}`, {
                    method: 'DELETE'
                });

                if (response.ok) {
                    // If we deleted the current conversation, start a new one
                    if (conversationToDelete === currentSessionId) {
                        startNewChat();
                    }

                    // Reload the conversation history
                    loadConversationHistory(currentCharacterId);
                    showToast('Conversation deleted', 'success');
                } else {
                    showToast('Failed to delete conversation', 'error');
                }
            } catch (e) {
                console.error('Error deleting conversation:', e);
                showToast('Failed to delete conversation', 'error');
            }

            closeDeleteModal();
        }

        // Helper to escape HTML
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        // Update the edit persona link with the current character ID
        function updateEditPersonaLink(characterId) {
            const editLink = document.getElementById('editPersonaLink');
            if (characterId) {
                editLink.href = `/persona/edit/${characterId}`;
                editLink.style.display = 'inline-flex';
            } else {
                editLink.style.display = 'none';
            }
        }

        // LLM Banner dismiss handler
        function dismissLLMBanner() {
            const llmBanner = document.getElementById('llmInfoBanner');
            llmBanner.classList.remove('show', 'warning');
            // Remember dismissal for this character
            if (currentCharacterId) {
                localStorage.setItem(`llmBannerDismissed_${currentCharacterId}`, 'true');
            }
        }

        // Reset dismissed state when character changes (handled in selectPersona)
        function resetLLMBannerDismiss() {
            const llmBanner = document.getElementById('llmInfoBanner');
            llmBanner.classList.remove('show', 'warning');
        }

        // Attach dismiss handler
        document.getElementById('llmBannerDismiss').addEventListener('click', dismissLLMBanner);

        function enableChat() {
            document.getElementById('messageInput').disabled = false;
            document.querySelector('.send-btn').disabled = false;
            setTimeout(() => document.getElementById('messageInput').focus(), 100);
        }

        function addMessage(sender, content) {
            const container = document.getElementById('chatContainer');
            const msg = document.createElement('div');
            msg.className = `message ${sender}`;
            msg.innerHTML = `
                <div class="message-sender">${sender === 'user' ? 'You' : currentPersona}</div>
                <div class="message-content">${content}</div>
            `;
            container.appendChild(msg);
            container.scrollTop = container.scrollHeight;
            chatHistory.push({ sender, content, timestamp: new Date() });
        }

        function addTypingIndicator() {
            const container = document.getElementById('chatContainer');
            const indicator = document.createElement('div');
            indicator.className = 'message assistant';
            indicator.id = 'typingIndicator';
            indicator.innerHTML = `
                <div class="message-sender">${currentPersona}</div>
                <div class="typing-indicator"><span></span><span></span><span></span></div>
            `;
            container.appendChild(indicator);
            container.scrollTop = container.scrollHeight;
        }

        function removeTypingIndicator() {
            const indicator = document.getElementById('typingIndicator');
            if (indicator) indicator.remove();
        }

        function clearChat() {
            document.getElementById('chatContainer').innerHTML = '';
            chatHistory = [];
        }

        async function loadExistingConversation() {
            if (!currentSessionId) return;

            authFetch(`/api/conversations/${currentSessionId}/history`)
                .then(r => r.json())
                .then(data => {
                    if (data && !data.error && data.character_id === currentCharacterId) {
                        clearChat();
                        data.history.forEach(msg => addMessage(msg.role, msg.content));
                    } else {
                        currentSessionId = null;
                        localStorage.removeItem('currentSessionId');
                        clearChat();
                        // Use personalized greeting
                        showPersonalizedGreeting(currentCharacterId, currentPersona);
                    }
                })
                .catch(() => {
                    currentSessionId = null;
                    localStorage.removeItem('currentSessionId');
                });
        }

        // ===== Sidebar Documents =====
        let currentTodos = [];
        let currentLifeAreas = {};

        function updateSidebarDocuments(category) {
            const sidebarDocs = document.getElementById('sidebarDocuments');
            const todoSection = document.getElementById('todoSection');
            const goalsSection = document.getElementById('goalsSection');
            const habitsSection = document.getElementById('habitsSection');
            const lifeAreasSection = document.getElementById('lifeAreasSection');

            if (!currentCharacterId) {
                sidebarDocs.style.display = 'none';
                return;
            }

            sidebarDocs.style.display = 'block';

            // Show appropriate sections based on category
            const isCoach = category && category.toLowerCase().includes('coach');
            const isFriend = category && (category.toLowerCase().includes('friend') || category.toLowerCase().includes('companion'));

            // Show todos for all except pure Friend personas
            todoSection.style.display = isFriend ? 'none' : 'block';
            if (!isFriend) loadTodos(currentCharacterId);

            // Show goals and habits for all personas
            goalsSection.style.display = 'block';
            habitsSection.style.display = 'block';
            loadGoals(currentCharacterId);
            loadHabits(currentCharacterId);

            // Show Life Areas only for Coach personas
            lifeAreasSection.style.display = isCoach ? 'block' : 'none';
            if (isCoach) loadLifeAreas(currentCharacterId);
        }

        // ===== Todo Functions =====
        async function loadTodos(characterId) {
            try {
                const response = await authFetch(`/api/todos?character_id=${characterId}`);
                if (!response.ok) throw new Error('Failed to load');
                const data = await response.json();
                currentTodos = data.todos || [];
                renderTodos();
            } catch (e) {
                console.error('Failed to load todos:', e);
                document.getElementById('todoList').innerHTML =
                    '<p class="text-muted text-sm text-center" style="padding: var(--space-2);">Failed to load</p>';
            }
        }

        function renderTodos() {
            const container = document.getElementById('todoList');
            if (currentTodos.length === 0) {
                container.innerHTML = `
                    <p class="text-muted text-sm text-center" style="padding: var(--space-3);">
                        No tasks yet. Add one above or say "add to my todo" in chat.
                    </p>
                `;
                return;
            }

            container.innerHTML = currentTodos.map(todo => `
                <div class="todo-item ${todo.is_completed ? 'completed' : ''} todo-priority-${todo.priority}"
                     data-todo-id="${todo.id}">
                    <label class="todo-checkbox">
                        <input type="checkbox" ${todo.is_completed ? 'checked' : ''}
                               onchange="toggleTodo(${todo.id})">
                    </label>
                    <span class="todo-text">${escapeHtml(todo.text)}</span>
                    <button class="todo-delete" onclick="deleteTodo(${todo.id})" title="Delete">
                        <i data-lucide="x" style="width: 14px; height: 14px;"></i>
                    </button>
                </div>
            `).join('');

            if (typeof lucide !== 'undefined') lucide.createIcons();
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        async function toggleTodo(todoId) {
            try {
                await authFetch(`/api/todos/${todoId}/toggle`, { method: 'PUT' });
                await loadTodos(currentCharacterId);
            } catch (e) {
                showToast('Failed to update todo', 'error');
            }
        }

        async function deleteTodo(todoId) {
            try {
                await authFetch(`/api/todos/${todoId}`, { method: 'DELETE' });
                await loadTodos(currentCharacterId);
            } catch (e) {
                showToast('Failed to delete todo', 'error');
            }
        }

        function addTodoInline() {
            document.getElementById('todoAddForm').style.display = 'flex';
            document.getElementById('newTodoInput').focus();
        }

        function cancelAddTodo() {
            document.getElementById('todoAddForm').style.display = 'none';
            document.getElementById('newTodoInput').value = '';
        }

        async function saveTodo() {
            const input = document.getElementById('newTodoInput');
            const text = input.value.trim();
            if (!text) return;

            try {
                await authFetch('/api/todos', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        character_id: currentCharacterId,
                        text: text,
                        priority: 2
                    })
                });
                cancelAddTodo();
                await loadTodos(currentCharacterId);
            } catch (e) {
                showToast('Failed to add todo', 'error');
            }
        }

        function exportTodos() {
            if (!currentTodos || currentTodos.length === 0) {
                showToast('No todos to export', 'error');
                return;
            }

            // Build simple text content
            const personaName = document.getElementById('currentPersonaName')?.textContent || 'Todo';
            let text = personaName + ' Todo List\n';
            text += new Date().toLocaleDateString() + '\n\n';

            currentTodos.forEach(function(todo) {
                const check = todo.is_completed ? '[x]' : '[ ]';
                text += check + ' ' + todo.text + '\n';
            });

            // Download as text file
            const blob = new Blob([text], { type: 'text/plain' });
            const a = document.createElement('a');
            a.href = URL.createObjectURL(blob);
            a.download = 'todo-list.txt';
            a.click();
            URL.revokeObjectURL(a.href);
        }

        // ===== Life Areas Functions =====
        async function loadLifeAreas(characterId) {
            try {
                const response = await authFetch(`/api/life-areas?character_id=${characterId}`);
                if (!response.ok) throw new Error('Failed to load');
                const data = await response.json();
                currentLifeAreas = data.scorecard || {};
                renderLifeAreas(data.average);
            } catch (e) {
                console.error('Failed to load life areas:', e);
                document.getElementById('lifeAreasGrid').innerHTML =
                    '<p class="text-muted text-sm text-center" style="padding: var(--space-2); grid-column: 1/-1;">Failed to load</p>';
            }
        }

        function renderLifeAreas(average) {
            const container = document.getElementById('lifeAreasGrid');
            const avgDisplay = document.getElementById('lifeAreasAverage');

            avgDisplay.textContent = `Avg: ${average || '--'}`;

            const areaNames = {
                'career': 'Career',
                'finances': 'Money',
                'health': 'Health',
                'relationships': 'Love',
                'family': 'Family',
                'friendships': 'Friends',
                'growth': 'Growth',
                'recreation': 'Fun',
                'environment': 'Home',
                'contribution': 'Giving'
            };

            const areas = Object.entries(currentLifeAreas);

            container.innerHTML = areas.map(([area, data]) => {
                const score = data.score || 5;
                const scoreClass = score <= 3 ? 'score-low' : score <= 6 ? 'score-medium' : 'score-high';
                return `
                    <div class="life-area-item" onclick="editLifeArea('${area}')"
                         title="Click to update score">
                        <span class="life-area-name">${areaNames[area] || area}</span>
                        <div class="life-area-score">
                            <span class="life-area-score-value ${scoreClass}">${score}</span>
                            <div class="life-area-bar">
                                <div class="life-area-bar-fill" style="width: ${score * 10}%"></div>
                            </div>
                        </div>
                    </div>
                `;
            }).join('');
        }

        function editLifeArea(area) {
            const areaNames = {
                'career': 'Career/Work',
                'finances': 'Finances',
                'health': 'Health',
                'relationships': 'Relationships',
                'family': 'Family',
                'friendships': 'Friendships',
                'growth': 'Personal Growth',
                'recreation': 'Fun/Recreation',
                'environment': 'Environment',
                'contribution': 'Contribution'
            };

            const current = currentLifeAreas[area]?.score || 5;
            const newScore = prompt(`Rate your ${areaNames[area] || area} (1-10):`, current);

            if (newScore !== null) {
                const score = parseInt(newScore, 10);
                if (score >= 1 && score <= 10) {
                    updateLifeAreaScore(area, score);
                } else {
                    showToast('Please enter a number between 1 and 10', 'error');
                }
            }
        }

        async function updateLifeAreaScore(area, score) {
            try {
                await authFetch(`/api/life-areas/${area}`, {
                    method: 'PUT',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        character_id: currentCharacterId,
                        score: score
                    })
                });
                await loadLifeAreas(currentCharacterId);
            } catch (e) {
                showToast('Failed to update score', 'error');
            }
        }

        // ===== Goals Functions =====
        let currentGoals = [];

        async function loadGoals(characterId) {
            try {
                const response = await authFetch(`/api/tracking/goals?character_id=${characterId}`);
                if (!response.ok) throw new Error('Failed to load');
                const data = await response.json();
                currentGoals = data.goals || [];
                renderGoals();
            } catch (e) {
                console.error('Failed to load goals:', e);
                document.getElementById('goalsList').innerHTML =
                    '<p class="text-muted text-sm text-center" style="padding: var(--space-2);">Failed to load</p>';
            }
        }

        function renderGoals() {
            const container = document.getElementById('goalsList');
            if (currentGoals.length === 0) {
                container.innerHTML = `
                    <p class="text-muted text-sm text-center" style="padding: var(--space-3);">
                        No goals yet. Click + to add one.
                    </p>
                `;
                return;
            }

            container.innerHTML = currentGoals.map(goal => {
                const progress = goal.progress_percentage || 0;
                const progressText = goal.target_value
                    ? `${goal.current_value || 0}/${goal.target_value} ${goal.unit || ''}`
                    : `${Math.round(progress)}%`;
                const dueDate = goal.target_date ? new Date(goal.target_date).toLocaleDateString() : '';

                return `
                    <div class="goal-item" onclick="showGoalDetails(${goal.id})">
                        <div class="goal-header">
                            <span class="goal-title">${escapeHtml(goal.title)}</span>
                        </div>
                        <div class="goal-progress-bar">
                            <div class="goal-progress-fill" style="width: ${Math.min(100, progress)}%"></div>
                        </div>
                        <div class="goal-meta">
                            <span>${progressText}</span>
                            ${dueDate ? `<span>Due: ${dueDate}</span>` : ''}
                        </div>
                    </div>
                `;
            }).join('');
        }

        function showAddGoalModal() {
            const title = prompt('Goal title:');
            if (!title) return;

            const targetValue = prompt('Target value (optional, e.g., 10):');
            const unit = targetValue ? prompt('Unit (e.g., lbs, books, miles):') : null;

            createGoal(title, targetValue ? parseFloat(targetValue) : null, unit);
        }

        async function createGoal(title, targetValue, unit) {
            try {
                await authFetch('/api/tracking/goals', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        character_id: currentCharacterId,
                        title: title,
                        target_value: targetValue,
                        unit: unit
                    })
                });
                await loadGoals(currentCharacterId);
                showToast('Goal added!', 'success');
            } catch (e) {
                showToast('Failed to add goal', 'error');
            }
        }

        async function showGoalDetails(goalId) {
            const goal = currentGoals.find(g => g.id === goalId);
            if (!goal) return;

            const action = prompt(
                `${goal.title}\nProgress: ${goal.current_value || 0}/${goal.target_value || '?'} ${goal.unit || ''}\n\n` +
                `Enter progress to add (e.g., +5), or type "complete" to mark done, "delete" to remove:`
            );

            if (!action) return;

            if (action.toLowerCase() === 'delete') {
                await deleteGoal(goalId);
            } else if (action.toLowerCase() === 'complete') {
                await updateGoal(goalId, { status: 'completed' });
            } else {
                const value = parseFloat(action.replace('+', ''));
                if (!isNaN(value)) {
                    await logGoalProgress(goalId, value);
                }
            }
        }

        async function logGoalProgress(goalId, value) {
            try {
                await authFetch(`/api/tracking/goals/${goalId}/progress`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ value_change: value })
                });
                await loadGoals(currentCharacterId);
                showToast('Progress updated!', 'success');
            } catch (e) {
                showToast('Failed to update progress', 'error');
            }
        }

        async function updateGoal(goalId, updates) {
            try {
                await authFetch(`/api/tracking/goals/${goalId}`, {
                    method: 'PUT',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(updates)
                });
                await loadGoals(currentCharacterId);
                showToast('Goal updated!', 'success');
            } catch (e) {
                showToast('Failed to update goal', 'error');
            }
        }

        async function deleteGoal(goalId) {
            try {
                await authFetch(`/api/tracking/goals/${goalId}`, { method: 'DELETE' });
                await loadGoals(currentCharacterId);
                showToast('Goal deleted', 'success');
            } catch (e) {
                showToast('Failed to delete goal', 'error');
            }
        }

        // ===== Habits Functions =====
        let currentHabits = [];

        async function loadHabits(characterId) {
            try {
                const response = await authFetch(`/api/tracking/habits?character_id=${characterId}`);
                if (!response.ok) throw new Error('Failed to load');
                const data = await response.json();
                currentHabits = data.habits || [];
                renderHabits();
            } catch (e) {
                console.error('Failed to load habits:', e);
                document.getElementById('habitsList').innerHTML =
                    '<p class="text-muted text-sm text-center" style="padding: var(--space-2);">Failed to load</p>';
            }
        }

        function renderHabits() {
            const container = document.getElementById('habitsList');
            if (currentHabits.length === 0) {
                container.innerHTML = `
                    <p class="text-muted text-sm text-center" style="padding: var(--space-3);">
                        No habits yet. Click + to add one.
                    </p>
                `;
                return;
            }

            container.innerHTML = currentHabits.map(habit => {
                const isCompleted = habit.completed_today;
                const streak = habit.current_streak || 0;
                const streakClass = streak > 0 ? 'active' : '';

                return `
                    <div class="habit-item">
                        <button class="habit-check-btn ${isCompleted ? 'completed' : ''}"
                                onclick="toggleHabit(${habit.id}, ${isCompleted})"
                                title="${isCompleted ? 'Completed today!' : 'Mark as done'}">
                            ${isCompleted ? '<i data-lucide="check" style="width: 14px; height: 14px;"></i>' : ''}
                        </button>
                        <div class="habit-info" onclick="showHabitDetails(${habit.id})">
                            <div class="habit-title">${escapeHtml(habit.title)}</div>
                            ${streak > 0 ? `<div class="habit-streak ${streakClass}"> ${streak} day streak</div>` : ''}
                        </div>
                    </div>
                `;
            }).join('');

            if (typeof lucide !== 'undefined') lucide.createIcons();
        }

        function showAddHabitModal() {
            const title = prompt('Habit name (e.g., "Exercise 30 min"):');
            if (!title) return;

            createHabit(title);
        }

        async function createHabit(title) {
            try {
                await authFetch('/api/tracking/habits', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        character_id: currentCharacterId,
                        title: title,
                        frequency: 'daily'
                    })
                });
                await loadHabits(currentCharacterId);
                showToast('Habit added!', 'success');
            } catch (e) {
                showToast('Failed to add habit', 'error');
            }
        }

        async function toggleHabit(habitId, isCurrentlyCompleted) {
            if (isCurrentlyCompleted) {
                // Already completed today, do nothing or show message
                showToast('Already completed today!', 'info');
                return;
            }

            try {
                await authFetch(`/api/tracking/habits/${habitId}/complete`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({})
                });
                await loadHabits(currentCharacterId);
                showToast('Great job! ', 'success');
            } catch (e) {
                showToast('Failed to complete habit', 'error');
            }
        }

        async function showHabitDetails(habitId) {
            const habit = currentHabits.find(h => h.id === habitId);
            if (!habit) return;

            const action = prompt(
                `${habit.title}\n` +
                `Streak: ${habit.current_streak || 0} days\n` +
                `Best: ${habit.longest_streak || 0} days\n\n` +
                `Type "delete" to remove this habit:`
            );

            if (action && action.toLowerCase() === 'delete') {
                await deleteHabit(habitId);
            }
        }

        async function deleteHabit(habitId) {
            try {
                await authFetch(`/api/tracking/habits/${habitId}`, { method: 'DELETE' });
                await loadHabits(currentCharacterId);
                showToast('Habit deleted', 'success');
            } catch (e) {
                showToast('Failed to delete habit', 'error');
            }
        }

        // Export functionality
        let selectedExportFormat = 'pdf';
        let currentCharacterCategory = 'Assistant';
        let documentTypesCache = {};

        function toggleExportDropdown(event) {
            event.stopPropagation();
            const dropdown = document.getElementById('exportDropdownContent');
            dropdown.classList.toggle('show');

            // Load document types for current character category
            if (dropdown.classList.contains('show')) {
                loadDocumentTypes(currentCharacterCategory);
                document.addEventListener('click', closeExportDropdown);
            }
        }

        function closeExportDropdown() {
            const dropdown = document.getElementById('exportDropdownContent');
            dropdown.classList.remove('show');
            document.removeEventListener('click', closeExportDropdown);
        }

        async function loadDocumentTypes(category) {
            const section = document.getElementById('documentTypesSection');
            const list = document.getElementById('documentTypesList');
            const header = document.getElementById('documentTypesHeader');

            if (!category) {
                section.style.display = 'none';
                return;
            }

            // Check cache first
            if (documentTypesCache[category]) {
                renderDocumentTypes(documentTypesCache[category], category);
                return;
            }

            try {
                const response = await authFetch(`/api/export/document-types/${category}`);
                if (response.ok) {
                    const data = await response.json();
                    documentTypesCache[category] = data.document_types;
                    renderDocumentTypes(data.document_types, category);
                }
            } catch (error) {
                console.error('Failed to load document types:', error);
                section.style.display = 'none';
            }
        }

        function renderDocumentTypes(docTypes, category) {
            const section = document.getElementById('documentTypesSection');
            const list = document.getElementById('documentTypesList');
            const header = document.getElementById('documentTypesHeader');

            if (!docTypes || docTypes.length === 0) {
                section.style.display = 'none';
                return;
            }

            section.style.display = 'block';
            header.textContent = `Generate ${category} Document`;

            list.innerHTML = docTypes.map(dt => `
                <button class="export-dropdown-item" onclick="generateDocument('${dt.id}')" title="${dt.description}">
                    <i data-lucide="sparkles" class="export-icon"></i>
                    <span class="export-label">${dt.name}</span>
                    <span class="export-ext">.${selectedExportFormat}</span>
                </button>
            `).join('');

            // Reinitialize Lucide icons for new elements
            if (typeof lucide !== 'undefined') lucide.createIcons();
        }

        // Format button handlers
        document.addEventListener('DOMContentLoaded', function() {
            document.querySelectorAll('.format-btn').forEach(btn => {
                btn.addEventListener('click', function(e) {
                    e.stopPropagation();
                    document.querySelectorAll('.format-btn').forEach(b => b.classList.remove('active'));
                    this.classList.add('active');
                    selectedExportFormat = this.dataset.format;

                    // Update extension displays
                    document.querySelectorAll('#documentTypesList .export-ext').forEach(ext => {
                        ext.textContent = '.' + selectedExportFormat;
                    });
                });
            });
        });

        async function exportConversation(format) {
            closeExportDropdown();

            if (!currentSessionId) {
                alert('No active conversation to export');
                return;
            }

            try {
                const response = await authFetch(`/api/export/conversation/${currentSessionId}`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        format: format,
                        include_system: false,
                        include_timestamps: true
                    })
                });

                if (!response.ok) {
                    const error = await response.json();
                    throw new Error(error.detail || 'Export failed');
                }

                downloadFile(response, `conversation.${format}`);

            } catch (error) {
                console.error('Export error:', error);
                alert('Failed to export conversation: ' + error.message);
            }
        }

        async function generateDocument(documentType) {
            closeExportDropdown();

            if (!currentSessionId) {
                alert('No active conversation to generate document from');
                return;
            }

            // Show loading state
            const exportBtn = document.querySelector('#exportDropdown > button');
            const originalTitle = exportBtn.title;
            exportBtn.title = 'Generating document...';
            exportBtn.style.opacity = '0.5';
            exportBtn.disabled = true;

            try {
                const response = await authFetch(`/api/export/generate/${currentSessionId}`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        document_type: documentType,
                        format: selectedExportFormat,
                        sfw_mode: true
                    })
                });

                if (!response.ok) {
                    const error = await response.json();
                    throw new Error(error.detail || 'Document generation failed');
                }

                downloadFile(response, `document.${selectedExportFormat}`);

            } catch (error) {
                console.error('Document generation error:', error);
                alert('Failed to generate document: ' + error.message);
            } finally {
                exportBtn.title = originalTitle;
                exportBtn.style.opacity = '';
                exportBtn.disabled = false;
            }
        }

        async function downloadFile(response, defaultFilename) {
            // Get filename from Content-Disposition header
            const contentDisposition = response.headers.get('Content-Disposition');
            let filename = defaultFilename;
            if (contentDisposition) {
                const match = contentDisposition.match(/filename="(.+)"/);
                if (match) {
                    filename = match[1];
                }
            }

            // Download the file
            const blob = await response.blob();
            const url = window.URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            window.URL.revokeObjectURL(url);
            a.remove();
        }

        // Update character category when character changes
        function updateCharacterCategory(category) {
            currentCharacterCategory = category || 'Assistant';
            // Clear cache to force reload on next dropdown open
            delete documentTypesCache[currentCharacterCategory];
        }

        // Sidebar
        function toggleSidebar() {
            sidebarCollapsed = !sidebarCollapsed;
            const sidebar = document.getElementById('chatSidebar');
            const backdrop = document.getElementById('sidebarBackdrop');

            sidebar.classList.toggle('collapsed', sidebarCollapsed);

            // Handle mobile backdrop
            if (window.innerWidth <= 768) {
                if (sidebarCollapsed) {
                    backdrop.classList.remove('show');
                    document.body.style.overflow = '';
                } else {
                    backdrop.classList.add('show');
                    document.body.style.overflow = 'hidden';
                }
            }
        }

        // Close sidebar when clicking backdrop on mobile
        document.getElementById('sidebarBackdrop').addEventListener('click', function() {
            if (!sidebarCollapsed) {
                toggleSidebar();
            }
        });

        // Handle window resize - close sidebar on mobile when resizing
        window.addEventListener('resize', function() {
            const backdrop = document.getElementById('sidebarBackdrop');
            if (window.innerWidth > 768) {
                backdrop.classList.remove('show');
                document.body.style.overflow = '';
            }
        });

        // File upload
        function toggleFileUpload() {
            const zone = document.getElementById('fileUploadArea');
            if (zone.classList.contains('active')) {
                zone.classList.remove('active');
                selectedFile = null;
                document.getElementById('uploadedFileInfo').innerHTML = '';
            } else {
                zone.classList.add('active');
            }
        }

        const fileUploadArea = document.getElementById('fileUploadArea');
        const fileInput = document.getElementById('fileInput');

        ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(e => {
            fileUploadArea.addEventListener(e, ev => { ev.preventDefault(); ev.stopPropagation(); }, false);
        });

        ['dragenter', 'dragover'].forEach(e => {
            fileUploadArea.addEventListener(e, () => fileUploadArea.classList.add('dragover'), false);
        });

        ['dragleave', 'drop'].forEach(e => {
            fileUploadArea.addEventListener(e, () => fileUploadArea.classList.remove('dragover'), false);
        });

        fileUploadArea.addEventListener('drop', e => handleFiles(e.dataTransfer.files));
        fileInput.addEventListener('change', e => handleFiles(e.target.files));

        // Enable drag-and-drop anywhere on the chat area
        const chatMain = document.querySelector('.chat-main');
        if (chatMain) {
            ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(e => {
                chatMain.addEventListener(e, ev => { ev.preventDefault(); ev.stopPropagation(); }, false);
            });

            chatMain.addEventListener('dragenter', () => {
                chatMain.classList.add('drag-active');
            });

            chatMain.addEventListener('dragleave', (e) => {
                // Only remove if leaving the chat area entirely
                if (!chatMain.contains(e.relatedTarget)) {
                    chatMain.classList.remove('drag-active');
                }
            });

            chatMain.addEventListener('drop', e => {
                chatMain.classList.remove('drag-active');
                if (e.dataTransfer.files.length > 0) {
                    handleFiles(e.dataTransfer.files);
                }
            });
        }

        function handleFiles(files) {
            if (files.length > 0) {
                selectedFile = files[0];
                showFileInfo(selectedFile);
            }
        }

        function showFileInfo(file) {
            const sizeKB = (file.size / 1024).toFixed(1);
            document.getElementById('uploadedFileInfo').innerHTML = `
                <div class="uploaded-file">
                    <i data-lucide="file" style="width: 16px; height: 16px;"></i>
                    <span>${file.name} (${sizeKB} KB)</span>
                    <span class="remove-file" onclick="removeFile()">
                        <i data-lucide="x" style="width: 14px; height: 14px;"></i>
                    </span>
                </div>
            `;
            lucide.createIcons();
        }

        function removeFile() {
            selectedFile = null;
            document.getElementById('uploadedFileInfo').innerHTML = '';
            fileInput.value = '';
        }

        // Chat form
        document.getElementById('chatForm').addEventListener('submit', function(e) {
            e.preventDefault();
            const input = document.getElementById('messageInput');
            const message = input.value.trim();

            if (!message && !selectedFile) return;
            if (!currentCharacterId) {
                showToast('Please select a persona first', 'error');
                return;
            }

            addMessage('user', message || '[Document uploaded]');
            input.value = '';
            addTypingIndicator();

            if (selectedFile) {
                document.getElementById('processingStatus').classList.add('show');
            }

            const formData = new FormData();
            formData.append('message', message || 'Please analyze the uploaded document.');
            formData.append('character_id', currentCharacterId);
            if (currentSessionId) formData.append('session_id', currentSessionId);
            formData.append('use_documents', 'true');
            if (selectedFile) formData.append('file', selectedFile);

            const endpoint = selectedFile ? '/api/chat/with-document' : '/api/chat';
            const options = selectedFile ?
                { method: 'POST', body: formData } :
                {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        message, character_id: currentCharacterId,
                        session_id: currentSessionId, use_documents: true
                    })
                };

            authFetch(endpoint, options)
                .then(r => r.json())
                .then(data => {
                    removeTypingIndicator();
                    document.getElementById('processingStatus').classList.remove('show');

                    if (data.response) {
                        const isNewConversation = !currentSessionId || currentSessionId !== data.session_id;
                        currentSessionId = data.session_id;
                        localStorage.setItem('currentSessionId', currentSessionId);

                        // Refresh conversation history if this is a new conversation
                        if (isNewConversation && currentCharacterId) {
                            loadConversationHistory(currentCharacterId);
                            // Refresh again after delay to pick up LLM-generated title
                            setTimeout(() => {
                                loadConversationHistory(currentCharacterId);
                            }, 3000);
                        }

                        // Show LLM info banner if using default LLM
                        const llmBanner = document.getElementById('llmInfoBanner');
                        const llmText = document.getElementById('llmInfoText');
                        const llmLink = document.getElementById('llmBannerLink');
                        const llmDismiss = document.getElementById('llmBannerDismiss');

                        // Check if user dismissed the banner for this character
                        const dismissedKey = `llmBannerDismissed_${currentCharacterId}`;
                        const wasDismissed = localStorage.getItem(dismissedKey) === 'true';

                        if (data.using_default_llm && data.llm_message && !wasDismissed) {
                            llmText.textContent = data.llm_message;
                            // Only link to persona edit if we have a valid character ID
                            if (currentCharacterId) {
                                llmLink.href = `/persona/edit/${currentCharacterId}`;
                                llmLink.textContent = 'Configure';
                                llmLink.style.display = 'inline';
                            } else {
                                llmLink.href = '/settings';
                                llmLink.textContent = 'Settings';
                                llmLink.style.display = 'inline';
                            }
                            llmDismiss.style.display = 'inline';
                            llmBanner.classList.add('show', 'warning');
                        } else if (data.llm_provider && data.llm_model) {
                            // Show current LLM info (non-warning)
                            llmText.textContent = `Using ${data.llm_provider}/${data.llm_model}`;
                            if (currentCharacterId) {
                                llmLink.href = `/persona/edit/${currentCharacterId}`;
                                llmLink.textContent = 'Edit';
                                llmLink.style.display = 'inline';
                            } else {
                                llmLink.style.display = 'none';
                            }
                            llmDismiss.style.display = 'none';
                            llmBanner.classList.remove('warning');
                            llmBanner.classList.add('show');
                        }

                        let content = data.response;
                        if (data.uploaded_document?.analysis) {
                            content += generateDocumentAnalysisHTML(data.uploaded_document.analysis);
                        }
                        if (data.sources?.length > 0) {
                            content += `<div class="document-analysis"><strong>Sources:</strong><div style="margin-top: var(--space-2);">${renderSources(data.sources)}</div></div>`;
                        }

                        addMessage('assistant', content);

                        // Handle sidebar extractions (todos, life areas)
                        if (data.sidebar_extractions) {
                            const extractions = data.sidebar_extractions;
                            const todoCount = extractions.todos?.length || 0;
                            const lifeAreaCount = extractions.life_areas?.length || 0;

                            if (todoCount > 0 || lifeAreaCount > 0) {
                                // Show toast notification
                                let toastMsg = '';
                                if (todoCount > 0) {
                                    toastMsg = `Added ${todoCount} todo${todoCount > 1 ? 's' : ''} to your list`;
                                    if (currentCharacterId) loadTodos(currentCharacterId); // Refresh sidebar
                                }
                                if (lifeAreaCount > 0) {
                                    if (toastMsg) toastMsg += ' | ';
                                    toastMsg += `Updated ${lifeAreaCount} life area${lifeAreaCount > 1 ? 's' : ''}`;
                                    if (currentCharacterId) loadLifeAreas(currentCharacterId); // Refresh sidebar
                                }

                                // Simple toast (reusing LLM banner temporarily)
                                console.log('Sidebar extraction:', toastMsg);
                            }
                        }

                        // Always hide upload zone after successful message
                        document.getElementById('fileUploadArea').classList.remove('active');
                        if (selectedFile) {
                            removeFile();
                        }
                    } else {
                        addMessage('assistant', 'Sorry, I encountered an error. Please try again.');
                    }
                })
                .catch(err => {
                    removeTypingIndicator();
                    document.getElementById('processingStatus').classList.remove('show');
                    addMessage('assistant', 'Sorry, I encountered an error. Please try again.');
                });
        });

        function generateDocumentAnalysisHTML(analysis) {
            if (!analysis) return '';
            let html = '<div class="document-analysis"><strong>Document Analysis:</strong>';
            if (analysis.summary) html += `<p>${analysis.summary}</p>`;
            if (analysis.key_points?.length) {
                html += '<ul>' + analysis.key_points.map(p => `<li>${p}</li>`).join('') + '</ul>';
            }
            html += '</div>';
            return html;
        }

        function renderSources(sources) {
            return sources.map(s => {
                const name = typeof s === 'string' ? s : (s.filename || s.document_filename || 'Document');
                return `<span class="source-citation"><i data-lucide="file-text" style="width: 12px; height: 12px;"></i> ${name}</span>`;
            }).join('');
        }

        // Document panel
        function toggleDocumentPanel() {
            documentPanelOpen ? closeDocumentPanel() : openDocumentPanel();
        }

        function openDocumentPanel() {
            if (!currentCharacterId) {
                showToast('Please select a persona first', 'error');
                return;
            }
            document.getElementById('documentOverlay').classList.add('show');
            document.getElementById('documentPanel').classList.add('open');
            documentPanelOpen = true;
            loadCharacterDocuments();
        }

        function closeDocumentPanel() {
            document.getElementById('documentOverlay').classList.remove('show');
            document.getElementById('documentPanel').classList.remove('open');
            documentPanelOpen = false;
        }

        async function loadCharacterDocuments() {
            const container = document.getElementById('documentList');
            container.innerHTML = '<p class="text-muted text-center"><span class="spinner spinner-sm"></span> Loading...</p>';

            try {
                const r = await authFetch(`/api/documents/characters/${currentCharacterId}/documents`);
                const data = await r.json();

                if (r.ok && data.documents?.length) {
                    container.innerHTML = data.documents.map(doc => `
                        <div class="document-item">
                            <div style="display: flex; align-items: center; gap: var(--space-2);">
                                <i data-lucide="file-text" style="width: 20px; height: 20px; color: var(--text-muted);"></i>
                                <div>
                                    <div style="font-weight: var(--font-medium);">${doc.original_filename}</div>
                                    <div class="text-muted text-xs">${formatFileSize(doc.file_size)} &bull; ${doc.processing_status}</div>
                                </div>
                            </div>
                        </div>
                    `).join('') + `
                        <div style="margin-top: var(--space-4);">
                            <a href="/documents" class="btn btn-secondary" style="width: 100%;">Manage Documents</a>
                        </div>
                    `;
                    lucide.createIcons();
                } else {
                    container.innerHTML = `
                        <div class="text-center" style="padding: var(--space-8);">
                            <i data-lucide="file-x" style="width: 48px; height: 48px; color: var(--text-muted);"></i>
                            <p class="text-muted" style="margin-top: var(--space-4);">No documents assigned</p>
                            <a href="/documents" class="btn btn-secondary" style="margin-top: var(--space-2);">Upload Documents</a>
                        </div>
                    `;
                    lucide.createIcons();
                }
            } catch (err) {
                container.innerHTML = '<p class="text-muted text-center">Error loading documents</p>';
            }
        }

        function formatFileSize(bytes) {
            if (!bytes) return '0 B';
            const k = 1024;
            const sizes = ['B', 'KB', 'MB', 'GB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return parseFloat((bytes / Math.pow(k, i)).toFixed(1)) + ' ' + sizes[i];
        }

        // Toast notification
        function showToast(message, type = 'info') {
            const container = document.getElementById('toast-container') || createToastContainer();
            const toast = document.createElement('div');
            toast.className = `toast toast-${type}`;
            toast.innerHTML = `<span>${message}</span>`;
            container.appendChild(toast);
            setTimeout(() => {
                toast.style.animation = 'slideIn 0.3s ease reverse';
                setTimeout(() => toast.remove(), 300);
            }, 4000);
        }

        function createToastContainer() {
            const container = document.createElement('div');
            container.id = 'toast-container';
            container.className = 'toast-container';
            document.body.appendChild(container);
            return container;
        }
    </script>
</body>
</html>
