<!DOCTYPE html>
<html lang="en" class="theme-light">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chat - MinouChat</title>

    <!-- Prevent theme flash -->
    <script>
        (function() {
            const saved = localStorage.getItem('minouchat-theme');
            const theme = saved || (window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light');
            document.documentElement.classList.remove('theme-light', 'theme-dark');
            document.documentElement.classList.add('theme-' + theme);
        })();
    </script>

    <!-- Lucide Icons -->
    <script src="https://unpkg.com/lucide@latest/dist/umd/lucide.min.js"></script>

    <link rel="stylesheet" href="{{ url_for('static', path='css/theme.css') }}">

    <style>
        html, body {
            height: 100%;
            overflow: hidden;
        }

        .chat-layout {
            display: flex;
            height: 100vh;
        }

        /* Sidebar */
        .chat-sidebar {
            width: 280px;
            background: var(--bg-primary);
            border-right: 1px solid var(--border-color);
            display: flex;
            flex-direction: column;
            transition: width var(--transition-normal), margin var(--transition-normal);
        }

        .chat-sidebar.collapsed {
            width: 0;
            margin-left: -1px;
            overflow: hidden;
        }

        .sidebar-header {
            padding: var(--space-4);
            border-bottom: 1px solid var(--border-subtle);
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .sidebar-header a {
            color: var(--text-primary);
            font-weight: var(--font-semibold);
            font-size: var(--text-lg);
        }

        /* Persona Dropdown */
        .persona-dropdown-wrapper {
            padding: var(--space-3);
            border-bottom: 1px solid var(--border-subtle);
        }

        .persona-dropdown {
            width: 100%;
            padding: var(--space-3);
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: var(--radius-md);
            color: var(--text-primary);
            font-size: var(--text-sm);
            cursor: pointer;
            appearance: none;
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='16' height='16' viewBox='0 0 24 24' fill='none' stroke='%23888' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Cpath d='m6 9 6 6 6-6'/%3E%3C/svg%3E");
            background-repeat: no-repeat;
            background-position: right 12px center;
            padding-right: 40px;
        }

        .persona-dropdown:focus {
            outline: none;
            border-color: var(--text-primary);
        }

        /* New Chat Button */
        .new-chat-wrapper {
            padding: var(--space-2) var(--space-3);
        }

        .new-chat-btn {
            width: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: var(--space-2);
            padding: var(--space-3);
            background: var(--bg-primary);
            border: 1px dashed var(--border-color);
            border-radius: var(--radius-md);
            color: var(--text-secondary);
            font-size: var(--text-sm);
            cursor: pointer;
            transition: all var(--transition-fast);
        }

        .new-chat-btn:hover {
            border-style: solid;
            border-color: var(--text-primary);
            color: var(--text-primary);
            background: var(--bg-secondary);
        }

        /* Conversation History */
        /* Sidebar Documents Section */
        .sidebar-documents {
            padding: var(--space-3);
            border-bottom: 1px solid var(--border-subtle);
            max-height: 50vh;  /* Use viewport height for better scaling */
            min-height: 200px;
            overflow-y: auto;
            flex-shrink: 0;
        }

        /* Collapsible sections */
        .sidebar-section-collapsible {
            cursor: pointer;
            user-select: none;
        }

        .sidebar-section-collapsible .collapse-icon {
            transition: transform var(--transition-fast);
        }

        .sidebar-section-collapsible.collapsed .collapse-icon {
            transform: rotate(-90deg);
        }

        .sidebar-section-content {
            overflow: hidden;
            transition: max-height var(--transition-base);
        }

        .sidebar-section-content.collapsed {
            max-height: 0 !important;
            padding: 0;
        }

        .sidebar-section-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: var(--space-2);
        }

        .sidebar-section-header h4 {
            display: flex;
            align-items: center;
            gap: var(--space-2);
            font-size: var(--text-sm);
            font-weight: var(--font-medium);
            color: var(--text-primary);
            margin: 0;
        }

        /* Todo List Styles */
        .todo-list {
            display: flex;
            flex-direction: column;
            gap: var(--space-1);
        }

        .todo-item {
            display: flex;
            align-items: flex-start;
            gap: var(--space-2);
            padding: var(--space-2);
            background: var(--bg-secondary);
            border-radius: var(--radius-sm);
            transition: background var(--transition-fast);
        }

        .todo-item:hover {
            background: var(--bg-tertiary);
        }

        .todo-item.completed .todo-text {
            text-decoration: line-through;
            color: var(--text-muted);
        }

        .todo-checkbox {
            flex-shrink: 0;
            margin-top: 2px;
        }

        .todo-checkbox input {
            width: 16px;
            height: 16px;
            cursor: pointer;
            accent-color: var(--pop-primary);
        }

        .todo-text {
            flex: 1;
            font-size: var(--text-sm);
            color: var(--text-primary);
            word-break: break-word;
            line-height: 1.4;
        }

        .todo-delete {
            opacity: 0;
            padding: var(--space-1);
            background: transparent;
            border: none;
            color: var(--text-muted);
            cursor: pointer;
            transition: opacity var(--transition-fast);
            display: flex;
            align-items: center;
        }

        .todo-item:hover .todo-delete {
            opacity: 1;
        }

        .todo-delete:hover {
            color: var(--pop-danger);
        }

        /* Priority indicators */
        .todo-priority-1 { border-left: 3px solid var(--pop-danger); }
        .todo-priority-2 { border-left: 3px solid var(--pop-warning); }
        .todo-priority-3 { border-left: 3px solid var(--text-muted); }

        .todo-add-form {
            margin-top: var(--space-2);
            display: flex;
            flex-direction: column;
            gap: var(--space-2);
        }

        .todo-add-actions {
            display: flex;
            gap: var(--space-2);
            justify-content: flex-end;
        }

        /* Goals List Styles */
        .goals-list {
            display: flex;
            flex-direction: column;
            gap: var(--space-2);
        }

        .goal-item {
            padding: var(--space-2);
            background: var(--bg-secondary);
            border-radius: var(--radius-sm);
            cursor: pointer;
            transition: background var(--transition-fast);
        }

        .goal-item:hover {
            background: var(--bg-tertiary);
        }

        .goal-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            gap: var(--space-2);
            margin-bottom: var(--space-1);
        }

        .goal-title {
            font-size: var(--text-sm);
            font-weight: 500;
            color: var(--text-primary);
            flex: 1;
        }

        .goal-progress-bar {
            height: 4px;
            background: var(--bg-tertiary);
            border-radius: 2px;
            overflow: hidden;
        }

        .goal-progress-fill {
            height: 100%;
            background: var(--pop-primary);
            border-radius: 2px;
            transition: width var(--transition-base);
        }

        .goal-meta {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-top: var(--space-1);
            font-size: var(--text-xs);
            color: var(--text-muted);
        }

        .goal-item.completed {
            opacity: 0.6;
        }

        .goal-item.completed .goal-progress-fill {
            background: var(--pop-success);
        }

        .goal-delete-btn {
            background: transparent;
            border: none;
            color: var(--text-muted);
            cursor: pointer;
            padding: 2px;
            opacity: 0;
            transition: opacity var(--transition-fast), color var(--transition-fast);
        }

        .goal-item:hover .goal-delete-btn {
            opacity: 1;
        }

        .goal-delete-btn:hover {
            color: var(--pop-danger);
        }

        .sidebar-goal-btn {
            display: inline-flex;
            align-items: center;
            gap: 4px;
            padding: 4px 8px;
            font-size: var(--text-xs);
            font-weight: 500;
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: var(--radius-sm);
            color: var(--text-primary);
            cursor: pointer;
            transition: all var(--transition-fast);
        }

        .sidebar-goal-btn:hover:not(:disabled) {
            background: var(--pop-primary);
            border-color: var(--pop-primary);
            color: white;
        }

        .sidebar-goal-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        /* Habits List Styles */
        .habits-list {
            display: flex;
            flex-direction: column;
            gap: var(--space-1);
        }

        .habit-item {
            display: flex;
            align-items: center;
            gap: var(--space-2);
            padding: var(--space-2);
            background: var(--bg-secondary);
            border-radius: var(--radius-sm);
            transition: background var(--transition-fast);
        }

        .habit-item:hover {
            background: var(--bg-tertiary);
        }

        .habit-check-btn {
            width: 24px;
            height: 24px;
            border-radius: 50%;
            border: 2px solid var(--border-color);
            background: transparent;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all var(--transition-fast);
            flex-shrink: 0;
        }

        .habit-check-btn:hover {
            border-color: var(--pop-primary);
        }

        .habit-check-btn.completed {
            background: var(--pop-primary);
            border-color: var(--pop-primary);
            color: white;
        }

        .habit-info {
            flex: 1;
            min-width: 0;
        }

        .habit-title {
            font-size: var(--text-sm);
            color: var(--text-primary);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .habit-streak {
            font-size: var(--text-xs);
            color: var(--text-muted);
        }

        .habit-streak.active {
            color: var(--pop-warning);
        }

        /* Life Areas Scorecard */
        .life-areas-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: var(--space-2);
        }

        .life-area-item {
            display: flex;
            flex-direction: column;
            gap: 2px;
            padding: var(--space-2);
            background: var(--bg-secondary);
            border-radius: var(--radius-sm);
            cursor: pointer;
            transition: all var(--transition-fast);
        }

        .life-area-item:hover {
            background: var(--bg-tertiary);
        }

        .life-area-name {
            font-size: 10px;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .life-area-score {
            display: flex;
            align-items: center;
            gap: var(--space-1);
        }

        .life-area-score-value {
            font-size: var(--text-base);
            font-weight: var(--font-medium);
            color: var(--text-primary);
            min-width: 20px;
        }

        .life-area-bar {
            flex: 1;
            height: 4px;
            background: var(--bg-tertiary);
            border-radius: var(--radius-full);
            overflow: hidden;
        }

        .life-area-bar-fill {
            height: 100%;
            background: var(--pop-primary);
            transition: width var(--transition-normal);
        }

        /* Score color coding */
        .score-low { color: var(--pop-danger) !important; }
        .score-medium { color: var(--pop-warning) !important; }
        .score-high { color: var(--pop-success) !important; }

        .life-areas-average {
            font-size: var(--text-sm);
            font-weight: var(--font-medium);
            color: var(--text-secondary);
            background: var(--bg-secondary);
            padding: 2px 8px;
            border-radius: var(--radius-sm);
        }

        /* Life Area Score Modal */
        .life-area-modal-overlay {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            animation: fadeIn 0.2s ease;
        }

        .life-area-modal {
            background: var(--bg-primary);
            border: 1px solid var(--border-color);
            border-radius: var(--radius-lg);
            padding: var(--space-4);
            min-width: 280px;
            max-width: 320px;
            box-shadow: var(--shadow-lg);
            animation: slideUp 0.2s ease;
        }

        @keyframes slideUp {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .life-area-modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: var(--space-2);
        }

        .life-area-modal-header h4 {
            margin: 0;
            font-size: var(--text-base);
            font-weight: var(--font-medium);
        }

        .life-area-score-boxes {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: var(--space-2);
        }

        .life-area-score-box {
            width: 44px;
            height: 44px;
            border: 2px solid var(--border-color);
            border-radius: var(--radius-md);
            background: var(--bg-secondary);
            font-size: var(--text-base);
            font-weight: var(--font-medium);
            color: var(--text-primary);
            cursor: pointer;
            transition: all var(--transition-fast);
        }

        .life-area-score-box:hover {
            background: var(--bg-tertiary);
            border-color: var(--text-muted);
            transform: scale(1.05);
        }

        .life-area-score-box.selected {
            border-color: var(--pop-primary);
            background: rgba(59, 130, 246, 0.15);
            box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.3);
        }

        .life-area-score-box.score-low {
            color: var(--pop-danger);
        }

        .life-area-score-box.score-medium {
            color: var(--pop-warning);
        }

        .life-area-score-box.score-high {
            color: var(--pop-success);
        }

        .conversation-history-wrapper {
            flex: 1;
            display: flex;
            flex-direction: column;
            min-height: 0;
            overflow: hidden;
        }

        .conversation-history-wrapper .sidebar-section-header {
            padding: var(--space-2) var(--space-3);
            border-bottom: 1px solid var(--border-subtle);
            flex-shrink: 0;
        }

        .history-count {
            font-size: var(--text-xs);
            color: var(--text-muted);
            background: var(--bg-tertiary);
            padding: 2px 6px;
            border-radius: var(--radius-sm);
        }

        .conversation-history {
            flex: 1;
            overflow-y: auto;
            padding: var(--space-2) var(--space-3);
            max-height: none;
        }

        .conversation-history.collapsed {
            display: none;
        }

        .history-group {
            margin-bottom: var(--space-4);
        }

        .history-group-label {
            font-size: var(--text-xs);
            font-weight: var(--font-semibold);
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.05em;
            padding: var(--space-2) var(--space-2);
            margin-bottom: var(--space-1);
        }

        .conversation-item {
            display: flex;
            align-items: center;
            gap: var(--space-2);
            padding: var(--space-2) var(--space-3);
            border-radius: var(--radius-md);
            cursor: pointer;
            transition: all var(--transition-fast);
            margin-bottom: var(--space-1);
            position: relative;
        }

        .conversation-item:hover {
            background: var(--bg-secondary);
        }

        .conversation-item.active {
            background: var(--bg-tertiary);
        }

        .conversation-item-icon {
            flex-shrink: 0;
            width: 16px;
            height: 16px;
            color: var(--text-muted);
        }

        .conversation-item-title {
            flex: 1;
            font-size: var(--text-sm);
            color: var(--text-primary);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .conversation-item-delete {
            opacity: 0;
            padding: var(--space-1);
            background: transparent;
            border: none;
            color: var(--text-muted);
            cursor: pointer;
            border-radius: var(--radius-sm);
            transition: all var(--transition-fast);
            flex-shrink: 0;
        }

        .conversation-item:hover .conversation-item-delete {
            opacity: 1;
        }

        .conversation-item-delete:hover {
            color: var(--pop-danger);
            background: rgba(239, 68, 68, 0.1);
        }

        .history-empty {
            text-align: center;
            padding: var(--space-6) var(--space-4);
            color: var(--text-muted);
            font-size: var(--text-sm);
        }

        .history-empty svg {
            width: 32px;
            height: 32px;
            margin-bottom: var(--space-2);
            opacity: 0.5;
        }

        /* Legacy persona list styles - keeping for backward compatibility */
        .personas-list {
            flex: 1;
            overflow-y: auto;
            padding: var(--space-2);
        }

        .persona-item {
            display: flex;
            align-items: center;
            gap: var(--space-3);
            padding: var(--space-3);
            border-radius: var(--radius-md);
            cursor: pointer;
            transition: all var(--transition-fast);
            margin-bottom: var(--space-1);
        }

        .persona-item:hover {
            background: var(--bg-secondary);
        }

        .persona-item.active {
            background: var(--bg-tertiary);
        }

        .persona-avatar-sm {
            width: 36px;
            height: 36px;
            border-radius: 50%;
            background: var(--bg-tertiary);
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: var(--font-semibold);
            flex-shrink: 0;
        }

        .persona-item.active .persona-avatar-sm {
            background: var(--text-primary);
            color: var(--bg-primary);
        }

        .persona-details {
            flex: 1;
            min-width: 0;
        }

        .persona-name {
            font-weight: var(--font-medium);
            font-size: var(--text-sm);
            color: var(--text-primary);
        }

        .persona-category {
            font-size: var(--text-xs);
            color: var(--text-muted);
        }

        .sidebar-footer {
            padding: var(--space-3);
            border-top: 1px solid var(--border-subtle);
        }

        /* Delete Confirmation Modal */
        .delete-modal-overlay {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: var(--z-modal);
            opacity: 0;
            visibility: hidden;
            transition: all var(--transition-normal);
        }

        .delete-modal-overlay.show {
            opacity: 1;
            visibility: visible;
        }

        .delete-modal {
            background: var(--bg-primary);
            border-radius: var(--radius-lg);
            padding: var(--space-6);
            max-width: 400px;
            width: 90%;
            text-align: center;
        }

        .delete-modal h3 {
            margin: 0 0 var(--space-3) 0;
            font-size: var(--text-lg);
        }

        .delete-modal p {
            color: var(--text-muted);
            margin-bottom: var(--space-4);
        }

        .delete-modal-actions {
            display: flex;
            gap: var(--space-3);
            justify-content: center;
        }

        /* Main Chat Area */
        .chat-main {
            flex: 1;
            display: flex;
            flex-direction: column;
            min-width: 0;
            position: relative;
        }

        .chat-main.drag-active::after {
            content: 'Drop file here';
            position: absolute;
            inset: 0;
            background: rgba(59, 130, 246, 0.1);
            border: 3px dashed var(--pop-primary);
            border-radius: var(--radius-lg);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.25rem;
            font-weight: 500;
            color: var(--pop-primary);
            z-index: 100;
            pointer-events: none;
        }

        .chat-header {
            padding: var(--space-4);
            border-bottom: 1px solid var(--border-subtle);
            display: flex;
            align-items: center;
            justify-content: space-between;
            background: var(--bg-primary);
        }

        .chat-header-left {
            display: flex;
            align-items: center;
            gap: var(--space-3);
        }

        .sidebar-toggle {
            padding: var(--space-2);
            background: transparent;
            border: none;
            color: var(--text-secondary);
            cursor: pointer;
            border-radius: var(--radius-md);
            transition: all var(--transition-fast);
        }

        .sidebar-toggle:hover {
            background: var(--bg-secondary);
            color: var(--text-primary);
        }

        .chat-title {
            font-weight: var(--font-semibold);
        }

        .chat-header-actions {
            display: flex;
            align-items: center;
            gap: var(--space-2);
        }

        /* Export Dropdown */
        .export-dropdown {
            position: relative;
            display: inline-block;
        }

        .export-dropdown-content {
            display: none;
            position: absolute;
            right: 0;
            top: 100%;
            min-width: 200px;
            background: var(--bg-primary);
            border: 1px solid var(--border-color);
            border-radius: var(--radius-md);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            z-index: var(--z-dropdown);
            padding: var(--space-2) 0;
            margin-top: var(--space-1);
        }

        .export-dropdown-content.show {
            display: block;
        }

        .export-dropdown-header {
            padding: var(--space-2) var(--space-3);
            font-size: var(--text-xs);
            font-weight: var(--font-semibold);
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        .export-dropdown-item {
            display: flex;
            align-items: center;
            gap: var(--space-2);
            padding: var(--space-2) var(--space-3);
            color: var(--text-primary);
            text-decoration: none;
            font-size: var(--text-sm);
            cursor: pointer;
            transition: background var(--transition-fast);
            border: none;
            background: none;
            width: 100%;
            text-align: left;
        }

        .export-dropdown-item:hover {
            background: var(--bg-secondary);
        }

        .export-dropdown-item .export-icon {
            width: 16px;
            height: 16px;
            color: var(--text-muted);
        }

        .export-dropdown-item .export-label {
            flex: 1;
        }

        .export-dropdown-item .export-ext {
            font-size: var(--text-xs);
            color: var(--text-muted);
        }

        .export-dropdown-divider {
            height: 1px;
            background: var(--border-subtle);
            margin: var(--space-2) 0;
        }

        .format-btn {
            padding: 4px 8px;
            font-size: var(--text-xs);
            border: 1px solid var(--border-color);
            border-radius: var(--radius-sm);
            background: var(--bg-secondary);
            color: var(--text-secondary);
            cursor: pointer;
            transition: all var(--transition-fast);
        }

        .format-btn:hover {
            border-color: var(--text-primary);
            color: var(--text-primary);
        }

        .format-btn.active {
            background: var(--text-primary);
            color: var(--bg-primary);
            border-color: var(--text-primary);
        }

        .export-dropdown-item.loading {
            opacity: 0.5;
            pointer-events: none;
        }

        .export-dropdown-item.loading::after {
            content: " ...";
        }

        /* LLM Info Banner */
        .llm-info-banner {
            display: none;
            padding: var(--space-2) var(--space-4);
            background: rgba(59, 130, 246, 0.1);
            border-bottom: 1px solid rgba(59, 130, 246, 0.2);
            color: var(--text-muted);
            font-size: var(--text-sm);
            text-align: center;
        }

        .llm-info-banner.warning {
            background: rgba(234, 179, 8, 0.1);
            border-color: rgba(234, 179, 8, 0.2);
            color: #ca8a04;
        }

        .llm-info-banner.show {
            display: block;
        }

        .llm-info-banner.auto-collapsed {
            animation: bannerSlideUp 0.5s ease forwards;
        }

        @keyframes bannerSlideUp {
            from { max-height: 50px; opacity: 1; padding: var(--space-2) var(--space-4); }
            to { max-height: 0; opacity: 0; padding: 0 var(--space-4); overflow: hidden; }
        }

        .llm-info-banner a {
            color: inherit;
            text-decoration: underline;
            margin-left: var(--space-2);
        }

        .llm-banner-dismiss {
            background: none;
            border: none;
            color: inherit;
            font-size: 1.1rem;
            cursor: pointer;
            margin-left: var(--space-3);
            opacity: 0.7;
            padding: 0 var(--space-1);
            line-height: 1;
        }

        .llm-banner-dismiss:hover {
            opacity: 1;
        }

        /* Messages Area */
        .chat-messages {
            flex: 1;
            overflow-y: auto;
            padding: var(--space-4);
            background: var(--bg-secondary);
        }

        .message {
            margin-bottom: var(--space-4);
            max-width: 80%;
        }

        .message.user {
            margin-left: auto;
        }

        .message-content {
            padding: var(--space-3) var(--space-4);
            border-radius: var(--radius-lg);
            line-height: 1.5;
        }

        .message.user .message-content {
            background: var(--text-primary);
            color: var(--bg-primary);
            border-bottom-right-radius: var(--radius-sm);
        }

        /* Dark mode: Use a darker background for user messages for better visual comfort */
        .theme-dark .message.user .message-content {
            background: var(--bg-tertiary);
            color: var(--text-primary);
            border: 1px solid var(--border-color);
        }

        /* Edit persona link styling */
        .edit-persona-link {
            opacity: 0.6;
            transition: opacity var(--transition-fast);
        }

        .edit-persona-link:hover {
            opacity: 1;
        }

        .message.assistant .message-content {
            background: var(--bg-primary);
            color: var(--text-primary);
            border: 1px solid var(--border-color);
            border-bottom-left-radius: var(--radius-sm);
        }

        /* Links in chat messages */
        .message-content a {
            color: #3b82f6;
            text-decoration: underline;
            word-break: break-all;
        }

        .message-content a:hover {
            color: #2563eb;
        }

        .message.user .message-content a {
            color: #93c5fd;
        }

        .message.user .message-content a:hover {
            color: #bfdbfe;
        }

        /* Web Search Sources */
        .search-sources {
            margin: var(--space-2) 0 var(--space-4) 0;
            padding: var(--space-3);
            background: var(--bg-secondary);
            border-radius: var(--radius-lg);
            border: 1px solid var(--border-color);
        }

        .sources-header {
            display: flex;
            align-items: center;
            gap: var(--space-2);
            font-size: var(--text-xs);
            color: var(--text-muted);
            margin-bottom: var(--space-2);
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        .sources-list {
            display: flex;
            flex-wrap: wrap;
            gap: var(--space-2);
        }

        .search-source-link {
            display: flex;
            align-items: center;
            gap: var(--space-2);
            padding: var(--space-2) var(--space-3);
            background: var(--bg-primary);
            border: 1px solid var(--border-color);
            border-radius: var(--radius-md);
            text-decoration: none;
            color: var(--text-primary);
            font-size: var(--text-sm);
            transition: all 0.15s ease;
            max-width: 250px;
        }

        .search-source-link:hover {
            border-color: #3b82f6;
            background: rgba(59, 130, 246, 0.05);
        }

        .source-number {
            display: flex;
            align-items: center;
            justify-content: center;
            width: 18px;
            height: 18px;
            background: #3b82f6;
            color: white;
            border-radius: 50%;
            font-size: 10px;
            font-weight: 600;
            flex-shrink: 0;
        }

        .source-title {
            flex: 1;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .source-domain {
            font-size: var(--text-xs);
            color: var(--text-muted);
            flex-shrink: 0;
        }

        /* Search Offer Button */
        .search-offer {
            margin: var(--space-2) 0;
        }

        .search-offer-btn {
            display: inline-flex;
            align-items: center;
            gap: var(--space-2);
            padding: var(--space-2) var(--space-4);
            background: linear-gradient(135deg, #3b82f6 0%, #2563eb 100%);
            color: white;
            border: none;
            border-radius: var(--radius-full);
            font-size: var(--text-sm);
            font-weight: 500;
            cursor: pointer;
            transition: all 0.15s ease;
            box-shadow: 0 2px 4px rgba(59, 130, 246, 0.3);
        }

        .search-offer-btn:hover:not(:disabled) {
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(59, 130, 246, 0.4);
        }

        .search-offer-btn:disabled {
            opacity: 0.7;
            cursor: wait;
        }

        .search-offer-btn .spin {
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }

        .message-sender {
            font-size: var(--text-xs);
            color: var(--text-muted);
            margin-bottom: var(--space-1);
        }

        .message.user .message-sender {
            text-align: right;
        }

        /* Tracking Cards in Chat */
        .tracking-cards-container {
            display: flex;
            flex-direction: column;
            gap: var(--space-2);
            margin-top: var(--space-3);
            max-width: 400px;
        }

        .tracking-card {
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: var(--radius-md);
            padding: var(--space-3);
            transition: border-color var(--transition-fast);
        }

        .tracking-card:hover {
            border-color: var(--border-strong);
        }

        .tracking-card-goal {
            border-left: 3px solid var(--pop-primary);
        }

        .tracking-card-habit {
            border-left: 3px solid var(--pop-success);
        }

        .tracking-card-todo {
            border-left: 3px solid #f59e0b;
        }

        .tracking-card-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: var(--space-2);
        }

        .tracking-card-type {
            display: flex;
            align-items: center;
            gap: var(--space-1);
            font-size: var(--text-xs);
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        .tracking-card-dismiss {
            padding: var(--space-1);
            background: transparent;
            border: none;
            color: var(--text-muted);
            cursor: pointer;
            opacity: 0;
            transition: opacity var(--transition-fast), color var(--transition-fast);
        }

        .tracking-card:hover .tracking-card-dismiss {
            opacity: 1;
        }

        .tracking-card-dismiss:hover {
            color: var(--pop-danger);
        }

        .tracking-card-title {
            font-size: var(--text-sm);
            font-weight: var(--font-medium);
            color: var(--text-primary);
            margin-bottom: var(--space-2);
            line-height: 1.4;
        }

        .tracking-card-progress {
            height: 4px;
            background: var(--bg-tertiary);
            border-radius: var(--radius-full);
            margin-bottom: var(--space-1);
            overflow: hidden;
        }

        .tracking-card-progress-bar {
            height: 100%;
            background: var(--pop-primary);
            transition: width var(--transition-normal);
        }

        .tracking-card-progress-text {
            font-size: var(--text-xs);
            color: var(--text-muted);
            margin-bottom: var(--space-2);
        }

        .tracking-card-streak {
            font-size: var(--text-xs);
            color: #f59e0b;
            margin-bottom: var(--space-2);
        }

        .tracking-card-actions {
            display: flex;
            gap: var(--space-2);
            flex-wrap: wrap;
        }

        .tracking-card-btn {
            display: inline-flex;
            align-items: center;
            gap: var(--space-1);
            padding: var(--space-1) var(--space-2);
            font-size: var(--text-xs);
            font-weight: var(--font-medium);
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: var(--radius-sm);
            color: var(--text-primary);
            cursor: pointer;
            transition: all var(--transition-fast);
        }

        .tracking-card-btn:hover {
            background: var(--pop-primary);
            border-color: var(--pop-primary);
            color: white;
        }

        .tracking-card-btn.completed {
            background: var(--pop-success);
            border-color: var(--pop-success);
            color: white;
        }

        .tracking-card-btn-secondary {
            background: transparent;
            color: var(--text-muted);
        }

        .tracking-card-btn-secondary:hover {
            background: var(--bg-tertiary);
            border-color: var(--border-strong);
            color: var(--text-primary);
        }

        @media (max-width: 768px) {
            .tracking-cards-container {
                max-width: 100%;
            }
        }

        /* Chat Input */
        .chat-input-area {
            padding: var(--space-4);
            background: var(--bg-primary);
            border-top: 1px solid var(--border-subtle);
        }

        .file-upload-zone {
            border: 2px dashed var(--border-color);
            border-radius: var(--radius-md);
            padding: var(--space-4);
            text-align: center;
            margin-bottom: var(--space-3);
            display: none;
            transition: all var(--transition-fast);
        }

        .file-upload-zone.active {
            display: block;
        }

        .file-upload-zone.dragover {
            border-color: var(--pop-primary);
            background: rgba(59, 130, 246, 0.05);
        }

        .file-upload-zone input[type="file"] {
            display: none;
        }

        .uploaded-file {
            display: flex;
            align-items: center;
            gap: var(--space-2);
            padding: var(--space-2) var(--space-3);
            background: var(--bg-secondary);
            border-radius: var(--radius-md);
            margin-bottom: var(--space-3);
            font-size: var(--text-sm);
        }

        .uploaded-file .remove-file {
            margin-left: auto;
            cursor: pointer;
            color: var(--text-muted);
        }

        .uploaded-file .remove-file:hover {
            color: var(--pop-danger);
        }

        .chat-input-wrapper {
            display: flex;
            gap: var(--space-2);
        }

        .chat-input {
            flex: 1;
            padding: var(--space-3) var(--space-4);
            border: 1px solid var(--border-color);
            border-radius: var(--radius-lg);
            background: var(--bg-primary);
            color: var(--text-primary);
            font-size: var(--text-base);
            resize: none;
        }

        .chat-input:focus {
            outline: none;
            border-color: var(--text-primary);
        }

        .chat-input:disabled {
            background: var(--bg-secondary);
            cursor: not-allowed;
        }

        .send-btn {
            padding: var(--space-3) var(--space-4);
            background: var(--text-primary);
            color: var(--bg-primary);
            border: none;
            border-radius: var(--radius-lg);
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: var(--space-2);
            transition: all var(--transition-fast);
        }

        .send-btn:hover:not(:disabled) {
            opacity: 0.9;
        }

        .send-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        /* Web Search Button - small, subtle, blue */
        .search-btn {
            padding: var(--space-2);
            background: transparent;
            color: #3b82f6;
            border: 1px solid #3b82f6;
            border-radius: var(--radius-md);
            cursor: pointer;
            display: none;
            align-items: center;
            justify-content: center;
            width: 32px;
            height: 32px;
            min-width: 32px;
            transition: all 0.15s ease;
        }

        .search-btn:hover:not(:disabled) {
            background: rgba(59, 130, 246, 0.1);
            border-color: #2563eb;
            color: #2563eb;
        }

        .search-btn:disabled {
            opacity: 0.4;
            cursor: not-allowed;
        }

        .search-btn.visible {
            display: flex;
        }

        .search-btn.searching {
            background: rgba(59, 130, 246, 0.15);
            animation: pulse 1s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.6; }
        }

        /* Web Search Results Panel */
        .web-search-results {
            position: absolute;
            bottom: 100%;
            left: 0;
            right: 0;
            background: var(--bg-primary);
            border: 1px solid var(--border-color);
            border-radius: var(--radius-lg);
            margin-bottom: var(--space-2);
            max-height: 300px;
            overflow-y: auto;
            display: none;
            box-shadow: 0 -4px 6px -1px rgba(0, 0, 0, 0.1);
            z-index: 100;
        }

        .web-search-results.visible {
            display: block;
        }

        .web-search-results-header {
            padding: var(--space-3);
            border-bottom: 1px solid var(--border-subtle);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .web-search-results-header h4 {
            margin: 0;
            font-size: var(--text-sm);
            color: var(--text-secondary);
        }

        .web-search-result {
            padding: var(--space-3);
            border-bottom: 1px solid var(--border-subtle);
        }

        .web-search-result:last-child {
            border-bottom: none;
        }

        .web-search-result-title {
            font-size: var(--text-sm);
            font-weight: 500;
            color: var(--text-primary);
            margin-bottom: var(--space-1);
        }

        .web-search-result-title a {
            color: inherit;
            text-decoration: none;
        }

        .web-search-result-title a:hover {
            text-decoration: underline;
        }

        .web-search-result-snippet {
            font-size: var(--text-xs);
            color: var(--text-muted);
            line-height: 1.4;
        }

        .web-search-result-source {
            font-size: var(--text-xs);
            color: var(--accent-color);
            margin-top: var(--space-1);
        }

        /* Document Panel */
        .document-panel {
            position: fixed;
            top: 0;
            right: -400px;
            width: 400px;
            height: 100vh;
            background: var(--bg-primary);
            border-left: 1px solid var(--border-color);
            transition: right var(--transition-normal);
            z-index: var(--z-modal);
            display: flex;
            flex-direction: column;
        }

        .document-panel.open {
            right: 0;
        }

        .document-panel-header {
            padding: var(--space-4);
            border-bottom: 1px solid var(--border-subtle);
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .document-panel-body {
            flex: 1;
            overflow-y: auto;
            padding: var(--space-4);
        }

        .document-item {
            padding: var(--space-3);
            border: 1px solid var(--border-color);
            border-radius: var(--radius-md);
            margin-bottom: var(--space-2);
        }

        .document-item:hover {
            border-color: var(--text-muted);
        }

        .panel-overlay {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.3);
            z-index: calc(var(--z-modal) - 1);
            opacity: 0;
            visibility: hidden;
            transition: all var(--transition-normal);
        }

        .panel-overlay.show {
            opacity: 1;
            visibility: visible;
        }

        /* Source Citations */
        .source-citation {
            display: inline-flex;
            align-items: center;
            gap: var(--space-1);
            padding: var(--space-1) var(--space-2);
            background: var(--bg-tertiary);
            border-radius: var(--radius-sm);
            font-size: var(--text-xs);
            color: var(--text-secondary);
            cursor: pointer;
            margin-right: var(--space-1);
            margin-bottom: var(--space-1);
        }

        .source-citation:hover {
            background: var(--pop-primary);
            color: white;
        }

        .document-analysis {
            margin-top: var(--space-3);
            padding: var(--space-3);
            background: var(--bg-secondary);
            border-left: 3px solid var(--pop-primary);
            border-radius: 0 var(--radius-md) var(--radius-md) 0;
            font-size: var(--text-sm);
        }

        /* Processing Status */
        .processing-status {
            display: none;
            align-items: center;
            gap: var(--space-2);
            padding: var(--space-2) var(--space-3);
            background: var(--bg-secondary);
            border-radius: var(--radius-md);
            margin-bottom: var(--space-3);
            font-size: var(--text-sm);
            color: var(--text-secondary);
        }

        .processing-status.show {
            display: flex;
        }

        /* Typing indicator */
        .typing-indicator {
            display: flex;
            gap: 4px;
            padding: var(--space-3) var(--space-4);
            background: var(--bg-primary);
            border: 1px solid var(--border-color);
            border-radius: var(--radius-lg);
            width: fit-content;
        }

        .typing-indicator span {
            width: 8px;
            height: 8px;
            background: var(--text-muted);
            border-radius: 50%;
            animation: typing 1.4s infinite ease-in-out both;
        }

        .typing-indicator span:nth-child(1) { animation-delay: -0.32s; }
        .typing-indicator span:nth-child(2) { animation-delay: -0.16s; }

        @keyframes typing {
            0%, 80%, 100% { transform: scale(0.6); opacity: 0.5; }
            40% { transform: scale(1); opacity: 1; }
        }

        /* Mobile sidebar backdrop */
        .sidebar-backdrop {
            display: none;
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.5);
            z-index: calc(var(--z-modal) - 1);
            opacity: 0;
            transition: opacity var(--transition-normal);
        }

        .sidebar-backdrop.show {
            opacity: 1;
        }

        /* Mobile hamburger button */
        .mobile-menu-btn {
            display: none;
            align-items: center;
            justify-content: center;
            width: 40px;
            height: 40px;
            background: transparent;
            border: 1px solid var(--border-color);
            border-radius: var(--radius-md);
            cursor: pointer;
            color: var(--text-primary);
        }

        .mobile-menu-btn svg {
            width: 20px;
            height: 20px;
            stroke: currentColor;
        }

        /* Mobile */
        @media (max-width: 768px) {
            .chat-sidebar {
                position: fixed;
                left: 0;
                top: 0;
                height: 100%;
                z-index: var(--z-modal);
                transform: translateX(0);
                transition: transform var(--transition-normal);
            }

            .chat-sidebar.collapsed {
                transform: translateX(-100%);
            }

            .sidebar-backdrop {
                display: block;
            }

            .mobile-menu-btn {
                display: flex;
            }

            .message {
                max-width: 90%;
            }

            .chat-header {
                padding: var(--space-3);
            }

            .chat-input-area {
                padding: var(--space-3);
            }

            .chat-messages {
                padding: var(--space-3);
            }

            /* Touch-friendly persona items */
            .persona-item {
                min-height: 56px;
                padding: var(--space-4);
            }

            /* Hide sidebar toggle text on mobile */
            .sidebar-toggle span {
                display: none;
            }
        }

        @media (max-width: 480px) {
            .message {
                max-width: 95%;
            }

            .chat-header-actions {
                gap: var(--space-1);
            }

            .btn-sm {
                padding: var(--space-2);
            }
        }

        /* Mobile tracking optimizations */
        @media (max-width: 768px) {
            .sidebar-documents {
                max-height: 40vh;
                min-height: 150px;
            }

            .goal-item, .habit-item, .todo-item {
                padding: var(--space-3);
            }

            .habit-check-btn {
                width: 32px;
                height: 32px;
            }

            /* Start with history collapsed on mobile */
            .conversation-history-wrapper .conversation-history {
                max-height: 30vh;
            }
        }

        /* Empty state */
        .empty-chat {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            text-align: center;
            padding: var(--space-8);
            color: var(--text-muted);
        }

        .empty-chat svg {
            width: 64px;
            height: 64px;
            stroke: var(--text-muted);
            margin-bottom: var(--space-4);
        }
    </style>
</head>
<body>
    <!-- Mobile sidebar backdrop -->
    <div class="sidebar-backdrop" id="sidebarBackdrop"></div>

    <div class="chat-layout">
        <!-- Sidebar -->
        <aside class="chat-sidebar" id="chatSidebar">
            <div class="sidebar-header">
                <a href="/dashboard" style="display: flex; align-items: center; gap: 0.5rem;">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" style="width: 20px; height: 20px;">
                        <path d="M12 5c.67 0 1.35.09 2 .26 1.78-2 5.03-2.84 6.42-2.26 1.4.58-.42 7-.42 7 .57 1.07 1 2.24 1 3.44C21 17.9 16.97 21 12 21s-9-3-9-7.56c0-1.25.5-2.4 1-3.44 0 0-1.89-6.42-.5-7 1.39-.58 4.72.23 6.5 2.23A9.04 9.04 0 0 1 12 5Z"/>
                        <path d="M8 14v.5"/><path d="M16 14v.5"/><path d="M11.25 16.25h1.5L12 17l-.75-.75Z"/>
                    </svg>
                    MinouChat
                </a>
                <button class="theme-toggle" title="Toggle theme" aria-label="Toggle dark/light theme">
                    <svg class="icon-sun" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
                        <circle cx="12" cy="12" r="5"/>
                        <line x1="12" y1="1" x2="12" y2="3"/>
                        <line x1="12" y1="21" x2="12" y2="23"/>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/>
                        <line x1="1" y1="12" x2="3" y2="12"/>
                        <line x1="21" y1="12" x2="23" y2="12"/>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/>
                    </svg>
                    <svg class="icon-moon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"/>
                    </svg>
                </button>
            </div>

            <!-- Persona Dropdown -->
            <div class="persona-dropdown-wrapper">
                <select class="persona-dropdown" id="personaDropdown">
                    <option value="">Select a persona...</option>
                    {% for persona in personas %}
                    <option value="{{ persona.id }}"
                            data-name="{{ persona.name }}"
                            data-category="{{ persona.category or 'General' }}"
                            data-hide-category="{{ 'true' if persona.hide_category else 'false' }}">
                        {% if persona.hide_category %}
                        {{ persona.name }}
                        {% else %}
                        {{ persona.name }} ({{ persona.category or 'General' }})
                        {% endif %}
                    </option>
                    {% endfor %}
                </select>
            </div>

            <!-- Sidebar Documents Section -->
            <div class="sidebar-documents" id="sidebarDocuments" style="display: none;">
                <!-- Todo List (Collapsible) -->
                <div class="sidebar-todo-section" id="todoSection" style="display: none;">
                    <div class="sidebar-section-header sidebar-section-collapsible" onclick="toggleTodoCollapse(event)">
                        <h4>
                            <i data-lucide="chevron-down" class="collapse-icon" style="width: 14px; height: 14px;"></i>
                            Todo List
                        </h4>
                        <div style="display: flex; gap: 4px;">
                            <button class="btn btn-ghost btn-sm" onclick="event.stopPropagation(); exportTodos()" title="Export/Print">
                                <i data-lucide="printer" style="width: 14px; height: 14px;"></i>
                            </button>
                            <button class="btn btn-ghost btn-sm" onclick="event.stopPropagation(); addTodoInline()" title="Add todo">
                                <i data-lucide="plus" style="width: 14px; height: 14px;"></i>
                            </button>
                        </div>
                    </div>
                    <div class="todo-list sidebar-section-content" id="todoList">
                        <p class="text-muted text-sm text-center" style="padding: var(--space-2);">Loading...</p>
                    </div>
                    <div class="todo-add-form" id="todoAddForm" style="display: none;">
                        <input type="text" class="form-input form-input-sm"
                               placeholder="Add a task..." id="newTodoInput"
                               onkeypress="if(event.key==='Enter') saveTodo()">
                        <div class="todo-add-actions">
                            <button class="btn btn-sm btn-primary" onclick="saveTodo()">Add</button>
                            <button class="btn btn-sm btn-ghost" onclick="cancelAddTodo()">Cancel</button>
                        </div>
                    </div>
                </div>

                <!-- Goals Section (Collapsible) -->
                <div class="sidebar-goals-section" id="goalsSection" style="display: none;">
                    <div class="sidebar-section-header sidebar-section-collapsible" onclick="toggleGoalsCollapse(event)">
                        <h4>
                            <i data-lucide="chevron-down" class="collapse-icon" style="width: 14px; height: 14px;"></i>
                            Goals
                        </h4>
                        <button class="btn btn-ghost btn-sm" onclick="event.stopPropagation(); showAddGoalModal()" title="Add goal">
                            <i data-lucide="plus" style="width: 14px; height: 14px;"></i>
                        </button>
                    </div>
                    <div class="goals-list sidebar-section-content" id="goalsList">
                        <p class="text-muted text-sm text-center" style="padding: var(--space-2);">Loading...</p>
                    </div>
                </div>

                <!-- Habits Section (Collapsible) -->
                <div class="sidebar-habits-section" id="habitsSection" style="display: none;">
                    <div class="sidebar-section-header sidebar-section-collapsible" onclick="toggleHabitsCollapse(event)">
                        <h4>
                            <i data-lucide="chevron-down" class="collapse-icon" style="width: 14px; height: 14px;"></i>
                            Habits
                        </h4>
                        <button class="btn btn-ghost btn-sm" onclick="event.stopPropagation(); showAddHabitModal()" title="Add habit">
                            <i data-lucide="plus" style="width: 14px; height: 14px;"></i>
                        </button>
                    </div>
                    <div class="habits-list sidebar-section-content" id="habitsList">
                        <p class="text-muted text-sm text-center" style="padding: var(--space-2);">Loading...</p>
                    </div>
                </div>

                <!-- Life Areas Scorecard (Collapsible, for Coach personas) -->
                <div class="sidebar-life-areas" id="lifeAreasSection" style="display: none;">
                    <div class="sidebar-section-header sidebar-section-collapsible" onclick="toggleLifeAreasCollapse(event)">
                        <h4>
                            <i data-lucide="chevron-down" class="collapse-icon" style="width: 14px; height: 14px;"></i>
                            Life Areas
                        </h4>
                        <span class="life-areas-average" id="lifeAreasAverage">--</span>
                    </div>
                    <div class="life-areas-grid sidebar-section-content" id="lifeAreasGrid">
                        <p class="text-muted text-sm text-center" style="padding: var(--space-2); grid-column: 1/-1;">Loading...</p>
                    </div>
                </div>
            </div>

            <!-- New Chat Button -->
            <div class="new-chat-wrapper">
                <button class="new-chat-btn" id="newChatBtn" onclick="startNewChat()">
                    <i data-lucide="plus" style="width: 16px; height: 16px;"></i>
                    New Chat
                </button>
            </div>

            <!-- Conversation History (Collapsible) -->
            <div class="conversation-history-wrapper">
                <div class="sidebar-section-header sidebar-section-collapsible" onclick="toggleHistoryCollapse()">
                    <h4>
                        <i data-lucide="chevron-down" class="collapse-icon" style="width: 14px; height: 14px;"></i>
                        Chat History
                    </h4>
                    <span class="history-count" id="historyCount"></span>
                </div>
                <div class="conversation-history sidebar-section-content" id="conversationHistory">
                    <div class="history-empty">
                        <i data-lucide="message-square" style="width: 32px; height: 32px;"></i>
                        <p>Select a persona to see your chat history</p>
                    </div>
                </div>
            </div>

            <div class="sidebar-footer">
                <a href="/personas" class="btn btn-secondary" style="width: 100%;">
                    <i data-lucide="user-plus" style="width: 16px; height: 16px;"></i>
                    Manage Personas
                </a>
            </div>
        </aside>

        <!-- Delete Confirmation Modal -->
        <div class="delete-modal-overlay" id="deleteModalOverlay">
            <div class="delete-modal">
                <h3>Delete Conversation?</h3>
                <p>This will permanently delete this conversation and all its messages.</p>
                <div class="delete-modal-actions">
                    <button class="btn btn-secondary" onclick="closeDeleteModal()">Cancel</button>
                    <button class="btn btn-danger" onclick="confirmDeleteConversation()">Delete</button>
                </div>
            </div>
        </div>

        <!-- Main Chat -->
        <main class="chat-main">
            <header class="chat-header">
                <div class="chat-header-left">
                    <button class="sidebar-toggle" onclick="toggleSidebar()" title="Show/hide persona list">
                        <i data-lucide="panel-left" style="width: 20px; height: 20px;"></i>
                    </button>
                    <span class="chat-title" id="currentPersona">{{ active_persona or 'Select a persona' }}</span>
                    <a href="#" class="btn btn-ghost btn-sm edit-persona-link" id="editPersonaLink" style="display: none;" title="Edit this persona's settings">
                        <i data-lucide="settings" style="width: 16px; height: 16px;"></i>
                    </a>
                </div>

                <div class="chat-header-actions">
                    <button class="btn btn-ghost" onclick="toggleFileUpload()" title="Attach a file to include in the conversation (PDF, Word, Text, etc.)">
                        <i data-lucide="paperclip" style="width: 18px; height: 18px;"></i>
                    </button>
                    <button class="btn btn-ghost" onclick="toggleDocumentPanel()" title="View and manage uploaded documents for this conversation">
                        <i data-lucide="file-text" style="width: 18px; height: 18px;"></i>
                    </button>
                    <!-- Export Dropdown -->
                    <div class="export-dropdown" id="exportDropdown">
                        <button class="btn btn-ghost" onclick="toggleExportDropdown(event)" title="Generate document from conversation">
                            <i data-lucide="file-output" style="width: 18px; height: 18px;"></i>
                        </button>
                        <div class="export-dropdown-content" id="exportDropdownContent">
                            <!-- Basic Export Options -->
                            <div class="export-dropdown-header">Quick Export</div>
                            <button class="export-dropdown-item" onclick="exportConversation('pdf')">
                                <i data-lucide="file" class="export-icon"></i>
                                <span class="export-label">Full Transcript (PDF)</span>
                                <span class="export-ext">.pdf</span>
                            </button>
                            <button class="export-dropdown-item" onclick="exportConversation('md')">
                                <i data-lucide="file-code" class="export-icon"></i>
                                <span class="export-label">Full Transcript (Markdown)</span>
                                <span class="export-ext">.md</span>
                            </button>

                            <!-- Dynamic Document Types (loaded based on character category) -->
                            <div id="documentTypesSection" style="display: none;">
                                <div class="export-dropdown-divider"></div>
                                <div class="export-dropdown-header" id="documentTypesHeader">Generate Document</div>
                                <div id="documentTypesList">
                                    <!-- Populated dynamically by JavaScript -->
                                </div>
                            </div>

                            <!-- Format Selection Modal Trigger -->
                            <div class="export-dropdown-divider"></div>
                            <div class="export-dropdown-header">Output Format</div>
                            <div style="display: flex; gap: 4px; padding: 4px 12px;">
                                <button class="format-btn active" data-format="pdf" title="PDF">PDF</button>
                                <button class="format-btn" data-format="docx" title="Word">DOCX</button>
                                <button class="format-btn" data-format="md" title="Markdown">MD</button>
                                <button class="format-btn" data-format="txt" title="Plain Text">TXT</button>
                            </div>
                        </div>
                    </div>
                    <button class="btn btn-ghost" onclick="clearChat()" title="Clear all messages in this chat session">
                        <i data-lucide="trash-2" style="width: 18px; height: 18px;"></i>
                    </button>
                    <a href="/dashboard" class="btn btn-ghost" title="Return to the main dashboard">
                        <i data-lucide="layout-dashboard" style="width: 18px; height: 18px;"></i>
                    </a>
                </div>
            </header>

            <!-- LLM Info Banner (shown when using system default LLM) -->
            <div class="llm-info-banner" id="llmInfoBanner">
                <span id="llmInfoText">Using system default AI</span>
                <a id="llmBannerLink" href="/settings" title="Configure model">Configure</a>
                <button id="llmBannerDismiss" class="llm-banner-dismiss" title="Keep default" aria-label="Dismiss">&times;</button>
            </div>

            <div class="chat-messages" id="chatContainer">
                <!-- Messages will be added here -->
            </div>

            <div class="chat-input-area">
                <!-- File Upload Zone -->
                <div class="file-upload-zone" id="fileUploadArea">
                    <i data-lucide="upload-cloud" style="width: 32px; height: 32px; color: var(--text-muted);"></i>
                    <p class="text-muted text-sm" style="margin: var(--space-2) 0;">Drop files here or click to browse</p>
                    <input type="file" id="fileInput" accept=".pdf,.doc,.docx,.txt,.md,.csv,.xlsx,.xls" multiple>
                    <button type="button" class="btn btn-secondary btn-sm" onclick="document.getElementById('fileInput').click()">
                        Choose File
                    </button>
                    <p class="text-muted text-xs" style="margin-top: var(--space-2);">PDF, Word, Text, Markdown, CSV, Excel</p>
                </div>

                <!-- Processing Status -->
                <div class="processing-status" id="processingStatus">
                    <span class="spinner spinner-sm"></span>
                    Processing document...
                </div>

                <!-- Uploaded File Info -->
                <div id="uploadedFileInfo"></div>

                <!-- Chat Input -->
                <form id="chatForm" style="position: relative;">
                    <!-- Web Search Results Panel -->
                    <div class="web-search-results" id="webSearchResults">
                        <div class="web-search-results-header">
                            <h4><i data-lucide="globe" style="width: 14px; height: 14px; display: inline;"></i> Web Search Results</h4>
                            <button type="button" class="btn btn-ghost btn-sm" onclick="closeWebSearchResults()">
                                <i data-lucide="x" style="width: 14px; height: 14px;"></i>
                            </button>
                        </div>
                        <div id="webSearchResultsList"></div>
                    </div>

                    <div class="chat-input-wrapper">
                        <input type="text" class="chat-input" id="messageInput"
                               placeholder="Type your message..." disabled autocomplete="off">
                        <button type="submit" class="send-btn" disabled>
                            <i data-lucide="send" style="width: 18px; height: 18px;"></i>
                            Send
                        </button>
                        <button type="button" class="search-btn" id="webSearchBtn" title="Search web first, then respond">
                            <i data-lucide="search" style="width: 14px; height: 14px;"></i>
                        </button>
                    </div>
                </form>
            </div>
        </main>
    </div>

    <!-- Document Panel -->
    <div class="panel-overlay" id="documentOverlay" onclick="closeDocumentPanel()"></div>
    <aside class="document-panel" id="documentPanel">
        <div class="document-panel-header">
            <h3 style="font-size: var(--text-base); margin: 0;">Documents</h3>
            <button class="btn btn-ghost" onclick="closeDocumentPanel()">
                <i data-lucide="x" style="width: 20px; height: 20px;"></i>
            </button>
        </div>
        <div class="document-panel-body" id="documentList">
            <p class="text-muted text-center">Loading documents...</p>
        </div>
    </aside>

    <script src="{{ url_for('static', path='js/theme.js') }}"></script>

    {% if clerk_configured %}
    <!-- Clerk SDK for session token management -->
    <script
        async
        crossorigin="anonymous"
        data-clerk-publishable-key="{{ clerk_publishable_key }}"
        src="https://cdn.jsdelivr.net/npm/@clerk/clerk-js@latest/dist/clerk.browser.js"
        type="text/javascript"
    ></script>
    {% endif %}

    <script>
        // Wait for Clerk to be ready
        let clerkReady = false;
        let clerkReadyPromise = new Promise((resolve) => {
            if (window.Clerk) {
                window.Clerk.load().then(() => {
                    clerkReady = true;
                    resolve();
                }).catch(() => resolve());
            } else {
                // Wait for Clerk script to load
                const checkClerk = setInterval(() => {
                    if (window.Clerk) {
                        clearInterval(checkClerk);
                        window.Clerk.load().then(() => {
                            clerkReady = true;
                            resolve();
                        }).catch(() => resolve());
                    }
                }, 100);
                // Timeout after 5 seconds
                setTimeout(() => {
                    clearInterval(checkClerk);
                    resolve();
                }, 5000);
            }
        });

        // Get fresh token from Clerk
        async function getFreshToken() {
            if (window.Clerk && window.Clerk.session) {
                try {
                    // Force refresh to get a new token
                    return await window.Clerk.session.getToken();
                } catch (e) {
                    console.warn('Could not get Clerk token:', e);
                    return null;
                }
            }
            return null;
        }

        // Authenticated fetch helper - refreshes token if needed and retries on 401
        async function authFetch(url, options = {}, retried = false) {
            // Wait for Clerk to be ready (with timeout)
            await Promise.race([clerkReadyPromise, new Promise(r => setTimeout(r, 2000))]);

            // Get a fresh token from Clerk if available
            const token = await getFreshToken();
            if (token) {
                options.headers = options.headers || {};
                options.headers['Authorization'] = `Bearer ${token}`;
            }

            const response = await fetch(url, options);

            // If 401 and we haven't retried yet, get a fresh token and retry
            if (response.status === 401 && !retried) {
                // Check if token was specifically expired
                const authError = response.headers.get('X-Auth-Error');
                console.log('Got 401, error type:', authError, '- refreshing token and retrying...');

                // Touch the session to ensure token refresh
                if (window.Clerk && window.Clerk.session) {
                    try {
                        await window.Clerk.session.touch();
                    } catch (e) {
                        console.warn('Session touch failed:', e);
                        // If touch fails, session might be invalid - redirect to login
                        if (authError !== 'token_expired') {
                            const returnTo = encodeURIComponent(window.location.pathname + window.location.search);
                            window.location.href = `/auth/login?return_to=${returnTo}`;
                            return response;
                        }
                    }
                }
                // Retry with fresh token
                return authFetch(url, { ...options, headers: {} }, true);
            }

            // If still 401 after retry, redirect to login
            if (response.status === 401 && retried) {
                console.error('Authentication failed after retry, redirecting to login');
                const returnTo = encodeURIComponent(window.location.pathname + window.location.search);
                window.location.href = `/auth/login?return_to=${returnTo}`;
            }

            return response;
        }

        // Proactive token refresh - keep the session alive
        let tokenRefreshInterval = null;
        function startTokenRefresh() {
            if (tokenRefreshInterval) return;
            // Refresh every 45 seconds (Clerk tokens expire at 60s)
            tokenRefreshInterval = setInterval(async () => {
                if (window.Clerk && window.Clerk.session) {
                    try {
                        await window.Clerk.session.touch();
                        console.log('Session refreshed proactively');
                    } catch (e) {
                        console.warn('Proactive session refresh failed:', e);
                    }
                }
            }, 45000);
        }

        // Start proactive refresh when Clerk is ready
        clerkReadyPromise.then(() => {
            if (window.Clerk && window.Clerk.session) {
                startTokenRefresh();
            }
        });

        // Initialize Lucide
        document.addEventListener('DOMContentLoaded', () => {
            if (typeof lucide !== 'undefined') lucide.createIcons();

            // Attach search button click handler
            const searchBtn = document.getElementById('webSearchBtn');
            if (searchBtn) {
                searchBtn.onclick = function(e) {
                    e.preventDefault();
                    performWebSearch();
                };
            }

            // Event delegation for tracking card actions
            document.getElementById('chatContainer').addEventListener('click', async (e) => {
                const actionBtn = e.target.closest('[data-action]');
                if (!actionBtn) return;

                const action = actionBtn.dataset.action;
                const type = actionBtn.dataset.type;
                const id = actionBtn.dataset.id;

                try {
                    switch (action) {
                        case 'complete-todo':
                            await handleToggleTodo(id, actionBtn);
                            break;
                        case 'complete-habit':
                            await handleCompleteHabit(id, actionBtn);
                            break;
                        case 'log-progress':
                            await handleLogGoalProgress(id, actionBtn);
                            break;
                        case 'check-in-goal':
                            await handleCheckInGoal(id, actionBtn);
                            break;
                        case 'view-in-sidebar':
                            handleViewInSidebar(type);
                            break;
                        case 'dismiss':
                            actionBtn.closest('.tracking-card').remove();
                            break;
                    }
                } catch (error) {
                    console.error('Tracking card action failed:', error);
                }
            });
        });

        // Tracking card action handlers
        async function handleToggleTodo(todoId, btn) {
            const response = await authFetch(`/api/tracking/todos/${todoId}/toggle`, {
                method: 'POST'
            });

            if (response.ok) {
                const card = btn.closest('.tracking-card');
                if (card) {
                    card.classList.add('completed');
                    btn.innerHTML = '<i data-lucide="check-circle" style="width: 14px; height: 14px;"></i> Done';
                    btn.classList.add('completed');
                    btn.disabled = true;
                    if (typeof lucide !== 'undefined') lucide.createIcons();
                }
                if (currentCharacterId) loadTodos(currentCharacterId);
            }
        }

        async function handleCompleteHabit(habitId, btn) {
            const response = await authFetch(`/api/tracking/habits/${habitId}/complete`, {
                method: 'POST'
            });

            if (response.ok) {
                const data = await response.json();
                const card = btn.closest('.tracking-card');
                if (card) {
                    btn.innerHTML = '<i data-lucide="check" style="width: 14px; height: 14px;"></i> Done Today';
                    btn.classList.add('completed');
                    if (typeof lucide !== 'undefined') lucide.createIcons();
                    // Update streak display
                    if (data.current_streak > 0) {
                        let streakEl = card.querySelector('.tracking-card-streak');
                        if (!streakEl) {
                            streakEl = document.createElement('div');
                            streakEl.className = 'tracking-card-streak';
                            card.querySelector('.tracking-card-title').after(streakEl);
                        }
                        streakEl.textContent = ` ${data.current_streak} day streak`;
                    }
                }
                if (currentCharacterId) loadHabits(currentCharacterId);
            }
        }

        async function handleLogGoalProgress(goalId, btn) {
            const value = prompt('Enter progress value:');
            if (!value) return;

            const numValue = parseFloat(value);
            if (isNaN(numValue)) {
                alert('Please enter a valid number');
                return;
            }

            const response = await authFetch(`/api/tracking/goals/${goalId}/progress`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ value_change: numValue })
            });

            if (response.ok) {
                const data = await response.json();
                updateGoalCardProgress(btn, data);
                if (currentCharacterId) loadGoals(currentCharacterId);
            }
        }

        async function handleCheckInGoal(goalId, btn) {
            // Simple +1 check-in for completion-based goals
            const response = await authFetch(`/api/tracking/goals/${goalId}/progress`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ value_change: 1 })
            });

            if (response.ok) {
                const data = await response.json();
                updateGoalCardProgress(btn, data);

                // Show brief success feedback
                btn.innerHTML = '<i data-lucide="check" style="width: 14px; height: 14px;"></i> Checked In!';
                btn.classList.add('completed');
                if (typeof lucide !== 'undefined') lucide.createIcons();

                // Reset button after delay
                setTimeout(() => {
                    btn.innerHTML = '<i data-lucide="check-circle" style="width: 14px; height: 14px;"></i> Check In (+1)';
                    btn.classList.remove('completed');
                    if (typeof lucide !== 'undefined') lucide.createIcons();
                }, 2000);

                if (currentCharacterId) loadGoals(currentCharacterId);
            }
        }

        function updateGoalCardProgress(btn, data) {
            const card = btn.closest('.tracking-card');
            if (card) {
                const progressBar = card.querySelector('.tracking-card-progress-bar');
                const progressText = card.querySelector('.tracking-card-progress-text');
                const progress = data.target_value ? Math.min(100, Math.round((data.current_value / data.target_value) * 100)) : 0;

                if (progressBar) {
                    progressBar.style.width = `${progress}%`;
                }
                if (progressText) {
                    progressText.textContent = `${Math.floor(data.current_value || 0)}${data.target_value ? ` / ${data.target_value}` : ''} ${data.unit || ''} (${progress}%)`;
                }

                // Check if goal is complete
                if (data.target_value && data.current_value >= data.target_value) {
                    card.classList.add('completed');
                }
            }
        }

        function handleViewInSidebar(type) {
            const sectionMap = {
                'goal': 'goalsSection',
                'habit': 'habitsSection',
                'todo': 'todoSection'
            };

            const section = document.getElementById(sectionMap[type]);
            if (section) {
                // Expand section if collapsed
                const header = section.querySelector('.collapsible-header');
                if (header && header.classList.contains('collapsed')) {
                    header.click();
                }
                section.scrollIntoView({ behavior: 'smooth', block: 'start' });
                // Brief highlight
                section.style.boxShadow = '0 0 0 2px var(--pop-primary)';
                setTimeout(() => section.style.boxShadow = '', 1500);
            }
        }

        // State
        let currentCharacterId = new URLSearchParams(window.location.search).get('character_id');
        let currentPersona = '';
        let currentSessionId = localStorage.getItem('currentSessionId');
        let chatHistory = [];
        let selectedFile = null;
        let userMessageCount = 0;  // Track user messages for auto-collapse of LLM banner
        // Initialize sidebar state based on screen size
        let sidebarCollapsed = window.innerWidth <= 768;
        let documentPanelOpen = false;
        let conversationToDelete = null;  // Track which conversation is pending deletion

        // Apply initial collapsed state for mobile
        if (sidebarCollapsed) {
            document.getElementById('chatSidebar').classList.add('collapsed');
        }

        // Initialize if character_id present
        if (currentCharacterId) {
            authFetch(`/api/characters/${currentCharacterId}`)
                .then(r => r.json())
                .then(data => {
                    if (data && !data.error) {
                        currentPersona = data.name;
                        document.getElementById('currentPersona').textContent = data.name;
                        updateEditPersonaLink(currentCharacterId);

                        // Update character category for export document types
                        updateCharacterCategory(data.category);

                        // Update sidebar documents (todos for Assistant, life areas for Coach)
                        updateSidebarDocuments(data.category);

                        // Check web search capability from character data
                        checkWebSearchCapability(data);

                        enableChat();

                        // Set dropdown to this character
                        const dropdown = document.getElementById('personaDropdown');
                        dropdown.value = currentCharacterId;

                        // Load conversation history for this character
                        loadConversationHistory(currentCharacterId);

                        if (currentSessionId) {
                            loadExistingConversation();
                        } else {
                            // Fetch personalized greeting
                            showPersonalizedGreeting(currentCharacterId, data.name);
                        }
                    }
                });
        }

        // Fetch and display a personalized greeting
        async function showPersonalizedGreeting(characterId, fallbackName) {
            try {
                const response = await authFetch(`/api/characters/${characterId}/greeting`);
                if (response.ok) {
                    const data = await response.json();
                    addMessage('assistant', data.greeting);
                } else {
                    // Fallback to simple greeting
                    addMessage('assistant', `Hi there! I'm ${fallbackName}. What's on your mind?`);
                }
            } catch (e) {
                // Fallback on error
                addMessage('assistant', `Hi there! I'm ${fallbackName}. What's on your mind?`);
            }
        }

        // Persona selection via dropdown
        document.getElementById('personaDropdown').addEventListener('change', function() {
            const selectedOption = this.options[this.selectedIndex];
            if (this.value) {
                selectPersona(selectedOption.dataset.name, this.value, selectedOption.dataset.category);
            }
        });

        // Web search state
        let webSearchEnabled = false;
        let webSearchResults = [];

        // Check if character has web search capability from character data
        function checkWebSearchCapability(characterData) {
            // Check capabilities.web_search from character data
            const capabilities = characterData?.capabilities || {};
            webSearchEnabled = capabilities.web_search === true;
            updateWebSearchButton();
            console.log('Web search capability:', webSearchEnabled, 'from capabilities:', capabilities);
        }

        // Update web search button visibility
        function updateWebSearchButton() {
            const searchBtn = document.getElementById('webSearchBtn');
            if (webSearchEnabled) {
                searchBtn.classList.add('visible');
            } else {
                searchBtn.classList.remove('visible');
            }
        }

        // Perform web search - submits message with search flag to include web results in LLM context
        async function performWebSearch() {
            console.log('[Search] performWebSearch called');
            const messageInput = document.getElementById('messageInput');
            const message = messageInput.value.trim();

            if (!message) {
                showToast('Enter a message first', 'warning');
                return;
            }

            if (!currentCharacterId) {
                showToast('Select a persona first', 'warning');
                return;
            }

            const searchBtn = document.getElementById('webSearchBtn');
            const sendBtn = document.querySelector('.send-btn');
            searchBtn.classList.add('searching');
            searchBtn.disabled = true;
            sendBtn.disabled = true;

            // Show user message immediately
            addMessage('user', message);
            messageInput.value = '';
            addTypingIndicator();

            const requestBody = {
                message: message,
                character_id: currentCharacterId,
                session_id: currentSessionId,
                use_documents: true,
                search: true  // Flag to trigger web search
            };
            console.log('[Search] Sending request with body:', requestBody);

            try {
                const response = await authFetch('/api/chat', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(requestBody)
                });

                removeTypingIndicator();

                if (!response.ok) {
                    const error = await response.json();
                    throw new Error(error.error || error.detail || 'Request failed');
                }

                const data = await response.json();

                if (data.response) {
                    currentSessionId = data.session_id;
                    localStorage.setItem('currentSessionId', currentSessionId);
                    addMessage('assistant', data.response);

                    // Display web search sources if available
                    if (data.web_search_results && data.web_search_results.length > 0) {
                        addSearchSources(data.web_search_results);
                    }

                    // Refresh conversation history
                    if (currentCharacterId) {
                        loadConversationHistory(currentCharacterId);
                    }
                } else if (data.error) {
                    showToast(data.error, 'error');
                }

            } catch (e) {
                removeTypingIndicator();
                console.error('Search chat error:', e);
                showToast(e.message || 'Search failed', 'error');
            } finally {
                searchBtn.classList.remove('searching');
                searchBtn.disabled = false;
                sendBtn.disabled = false;
            }
        }

        // Display web search results
        function displayWebSearchResults(data) {
            const resultsPanel = document.getElementById('webSearchResults');
            const resultsList = document.getElementById('webSearchResultsList');

            if (!data.results || data.results.length === 0) {
                resultsList.innerHTML = '<div class="web-search-result"><p class="text-muted">No results found</p></div>';
            } else {
                resultsList.innerHTML = data.results.map(result => `
                    <div class="web-search-result">
                        <div class="web-search-result-title">
                            <a href="${result.url}" target="_blank" rel="noopener noreferrer">${result.title}</a>
                        </div>
                        <div class="web-search-result-snippet">${result.snippet}</div>
                        <div class="web-search-result-source">${result.source}</div>
                    </div>
                `).join('');
            }

            resultsPanel.classList.add('visible');
            lucide.createIcons();
        }

        // Close web search results panel
        function closeWebSearchResults() {
            document.getElementById('webSearchResults').classList.remove('visible');
            webSearchResults = [];
        }

        function selectPersona(name, characterId, category) {
            currentPersona = name;
            currentCharacterId = characterId;
            currentSessionId = null;  // Clear session for new persona
            localStorage.removeItem('currentSessionId');
            userMessageCount = 0;  // Reset message counter for LLM banner

            document.getElementById('currentPersona').textContent = name;

            // Show edit persona link
            updateEditPersonaLink(characterId);

            // Update character category for export document types
            updateCharacterCategory(category);

            // Update sidebar documents (todos for Assistant, life areas for Coach)
            updateSidebarDocuments(category);

            // Hide the LLM banner until we get a chat response with LLM info
            resetLLMBannerDismiss();

            // Load conversation history for this persona
            loadConversationHistory(characterId);

            // Fetch character data to check web search capability
            authFetch(`/api/characters/${characterId}`)
                .then(r => r.json())
                .then(data => {
                    if (data && !data.error) {
                        checkWebSearchCapability(data);
                    }
                })
                .catch(e => {
                    console.error('Error fetching character for capability check:', e);
                    webSearchEnabled = false;
                    updateWebSearchButton();
                });

            // Close any open web search results
            closeWebSearchResults();

            enableChat();
            clearChat();
            // Use personalized greeting instead of generic one
            showPersonalizedGreeting(characterId, name);

            // Update URL without reloading
            const url = new URL(window.location);
            url.searchParams.set('character_id', characterId);
            window.history.pushState({}, '', url);
        }

        // Start a new chat (clear current conversation)
        function startNewChat() {
            if (!currentCharacterId) {
                showToast('Please select a persona first', 'error');
                return;
            }

            currentSessionId = null;
            localStorage.removeItem('currentSessionId');
            userMessageCount = 0;  // Reset message counter for LLM banner
            clearChat();
            showPersonalizedGreeting(currentCharacterId, currentPersona);

            // Update active state in conversation list
            document.querySelectorAll('.conversation-item').forEach(item => {
                item.classList.remove('active');
            });

            showToast('Started new conversation', 'success');
        }

        // Load conversation history for a character
        async function loadConversationHistory(characterId) {
            const container = document.getElementById('conversationHistory');
            container.innerHTML = '<div class="history-empty"><span class="spinner spinner-sm"></span><p>Loading...</p></div>';

            try {
                const response = await authFetch(`/api/conversations/character/${characterId}`);
                if (!response.ok) {
                    throw new Error('Failed to load conversations');
                }

                const data = await response.json();
                renderConversationHistory(data.groups);
            } catch (e) {
                console.error('Error loading conversation history:', e);
                container.innerHTML = `
                    <div class="history-empty">
                        <i data-lucide="alert-circle" style="width: 32px; height: 32px;"></i>
                        <p>Could not load history</p>
                    </div>
                `;
                lucide.createIcons();
            }
        }

        // Render conversation history grouped by date
        function renderConversationHistory(groups) {
            const container = document.getElementById('conversationHistory');
            const countBadge = document.getElementById('historyCount');

            // Count total conversations
            const totalCount = Object.values(groups).reduce((sum, g) => sum + g.length, 0);
            if (countBadge) {
                countBadge.textContent = totalCount > 0 ? totalCount : '';
            }

            // Check if there are any conversations
            const hasConversations = Object.values(groups).some(g => g.length > 0);

            if (!hasConversations) {
                container.innerHTML = `
                    <div class="history-empty">
                        <i data-lucide="message-square" style="width: 32px; height: 32px;"></i>
                        <p>No conversations yet.<br>Start chatting!</p>
                    </div>
                `;
                lucide.createIcons();
                return;
            }

            const groupLabels = {
                today: 'Today',
                yesterday: 'Yesterday',
                previous_7_days: 'Previous 7 Days',
                older: 'Older'
            };

            let html = '';
            for (const [groupKey, conversations] of Object.entries(groups)) {
                if (conversations.length === 0) continue;

                html += `<div class="history-group">`;
                html += `<div class="history-group-label">${groupLabels[groupKey]}</div>`;

                for (const conv of conversations) {
                    const isActive = conv.id === currentSessionId ? 'active' : '';
                    html += `
                        <div class="conversation-item ${isActive}"
                             data-session-id="${conv.id}"
                             onclick="loadConversation('${conv.id}')">
                            <i data-lucide="message-square" class="conversation-item-icon"></i>
                            <span class="conversation-item-title">${escapeHtml(conv.title)}</span>
                            <button class="conversation-item-delete"
                                    onclick="event.stopPropagation(); showDeleteModal('${conv.id}')"
                                    title="Delete conversation">
                                <i data-lucide="trash-2" style="width: 14px; height: 14px;"></i>
                            </button>
                        </div>
                    `;
                }
                html += `</div>`;
            }

            container.innerHTML = html;
            lucide.createIcons();
        }

        // Load a specific conversation
        async function loadConversation(sessionId) {
            if (!sessionId) return;

            // Update active state
            document.querySelectorAll('.conversation-item').forEach(item => {
                item.classList.toggle('active', item.dataset.sessionId === sessionId);
            });

            currentSessionId = sessionId;
            localStorage.setItem('currentSessionId', sessionId);

            // Load conversation history
            try {
                const response = await authFetch(`/api/conversations/${sessionId}/history`);
                if (!response.ok) {
                    throw new Error('Failed to load conversation');
                }

                const data = await response.json();
                clearChat();

                if (data.history && data.history.length > 0) {
                    data.history.forEach(msg => addMessage(msg.role, msg.content));
                } else {
                    showPersonalizedGreeting(currentCharacterId, currentPersona);
                }
            } catch (e) {
                console.error('Error loading conversation:', e);
                showToast('Could not load conversation', 'error');
            }
        }

        // Delete conversation modal
        function showDeleteModal(sessionId) {
            conversationToDelete = sessionId;
            document.getElementById('deleteModalOverlay').classList.add('show');
        }

        function closeDeleteModal() {
            conversationToDelete = null;
            document.getElementById('deleteModalOverlay').classList.remove('show');
        }

        async function confirmDeleteConversation() {
            if (!conversationToDelete) return;

            try {
                const response = await authFetch(`/api/conversations/${conversationToDelete}`, {
                    method: 'DELETE'
                });

                if (response.ok) {
                    // If we deleted the current conversation, start a new one
                    if (conversationToDelete === currentSessionId) {
                        startNewChat();
                    }

                    // Reload the conversation history
                    loadConversationHistory(currentCharacterId);
                    showToast('Conversation deleted', 'success');
                } else {
                    showToast('Failed to delete conversation', 'error');
                }
            } catch (e) {
                console.error('Error deleting conversation:', e);
                showToast('Failed to delete conversation', 'error');
            }

            closeDeleteModal();
        }

        // Helper to escape HTML
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        // Tracking card rendering functions
        function renderTrackingCards(cards) {
            if (!cards || cards.length === 0) return '';

            return `
                <div class="tracking-cards-container">
                    ${cards.map(card => renderSingleCard(card)).join('')}
                </div>
            `;
        }

        function renderSingleCard(card) {
            const typeIcons = {
                goal: 'target',
                habit: 'repeat',
                todo: 'check-square'
            };

            const typeLabels = {
                goal: 'Goal',
                habit: 'Habit',
                todo: 'Todo'
            };

            let progressHtml = '';
            let actionsHtml = '';

            if (card.type === 'goal') {
                const progress = card.progress || 0;
                const isCompletion = card.goal_type === 'completion';

                progressHtml = `
                    <div class="tracking-card-progress">
                        <div class="tracking-card-progress-bar" style="width: ${progress}%"></div>
                    </div>
                    <div class="tracking-card-progress-text">
                        ${Math.floor(card.current_value || 0)}${card.target_value ? ` / ${card.target_value}` : ''} ${card.unit || ''} (${progress}%)
                    </div>
                `;

                if (isCompletion) {
                    // Daily check-in style button
                    actionsHtml = `
                        <button class="tracking-card-btn" data-action="check-in-goal" data-type="goal" data-id="${card.id}">
                            <i data-lucide="check-circle" style="width: 14px; height: 14px;"></i>
                            Check In (+1)
                        </button>
                    `;
                } else {
                    // Numeric progress entry
                    actionsHtml = `
                        <button class="tracking-card-btn" data-action="log-progress" data-type="goal" data-id="${card.id}">
                            <i data-lucide="plus" style="width: 14px; height: 14px;"></i>
                            Log Progress
                        </button>
                    `;
                }
            } else if (card.type === 'habit') {
                progressHtml = card.streak > 0 ? `<div class="tracking-card-streak"> ${card.streak} day streak</div>` : '';
                actionsHtml = `
                    <button class="tracking-card-btn ${card.completed_today ? 'completed' : ''}"
                            data-action="complete-habit" data-type="habit" data-id="${card.id}">
                        <i data-lucide="${card.completed_today ? 'check' : 'circle'}" style="width: 14px; height: 14px;"></i>
                        ${card.completed_today ? 'Done Today' : 'Mark Done'}
                    </button>
                `;
            } else if (card.type === 'todo') {
                actionsHtml = `
                    <button class="tracking-card-btn" data-action="complete-todo" data-type="todo" data-id="${card.id}">
                        <i data-lucide="check" style="width: 14px; height: 14px;"></i>
                        Complete
                    </button>
                `;
            }

            return `
                <div class="tracking-card tracking-card-${card.type}" data-card-id="${card.id}" data-card-type="${card.type}">
                    <div class="tracking-card-header">
                        <div class="tracking-card-type">
                            <i data-lucide="${typeIcons[card.type]}" style="width: 14px; height: 14px;"></i>
                            ${typeLabels[card.type]}
                        </div>
                        <button class="tracking-card-dismiss" data-action="dismiss" data-id="${card.id}" title="Dismiss">
                            <i data-lucide="x" style="width: 12px; height: 12px;"></i>
                        </button>
                    </div>
                    <div class="tracking-card-title">${escapeHtml(card.title || card.text || '')}</div>
                    ${progressHtml}
                    <div class="tracking-card-actions">
                        ${actionsHtml}
                        <button class="tracking-card-btn tracking-card-btn-secondary" data-action="view-in-sidebar" data-type="${card.type}">
                            <i data-lucide="sidebar" style="width: 14px; height: 14px;"></i>
                            View in Sidebar
                        </button>
                    </div>
                </div>
            `;
        }

        // Update the edit persona link with the current character ID
        function updateEditPersonaLink(characterId) {
            const editLink = document.getElementById('editPersonaLink');
            if (characterId) {
                editLink.href = `/persona/edit/${characterId}`;
                editLink.style.display = 'inline-flex';
            } else {
                editLink.style.display = 'none';
            }
        }

        // LLM Banner dismiss handler
        function dismissLLMBanner() {
            const llmBanner = document.getElementById('llmInfoBanner');
            llmBanner.classList.remove('show', 'warning');
            // Remember dismissal for this character
            if (currentCharacterId) {
                localStorage.setItem(`llmBannerDismissed_${currentCharacterId}`, 'true');
            }
        }

        // Reset dismissed state when character changes (handled in selectPersona)
        function resetLLMBannerDismiss() {
            const llmBanner = document.getElementById('llmInfoBanner');
            llmBanner.classList.remove('show', 'warning');
        }

        // Attach dismiss handler
        document.getElementById('llmBannerDismiss').addEventListener('click', dismissLLMBanner);

        function enableChat() {
            document.getElementById('messageInput').disabled = false;
            document.querySelector('.send-btn').disabled = false;
            setTimeout(() => document.getElementById('messageInput').focus(), 100);
        }

        // Convert URLs in text to clickable links
        function linkifyUrls(text) {
            // Match URLs starting with http:// or https://
            const urlRegex = /(https?:\/\/[^\s<>"')\]]+)/g;
            return text.replace(urlRegex, '<a href="$1" target="_blank" rel="noopener noreferrer">$1</a>');
        }

        // Phrases that indicate the LLM couldn't answer and search might help
        const SEARCH_SUGGESTION_PHRASES = [
            "i don't have access to real-time",
            "i don't have real-time",
            "i can't access current",
            "i cannot access current",
            "i suggest checking online",
            "check online resources",
            "checking online resources",
            "i don't have specific data",
            "i don't have current data",
            "i don't have direct access",
            "my knowledge cutoff",
            "my training data",
            "for the most up-to-date",
            "for up-to-date information",
            "for current information",
            "for the latest information",
            "i recommend searching",
            "you might want to search",
            "a quick search",
            "would you like me to conduct a web search",
            "would you like me to search",
            "would you like me to look up",
            "conduct a web search",
            "look up relevant articles",
            "find reliable sources",
            "help you find reliable sources"
        ];

        // Check if response suggests user should search
        function shouldOfferSearch(responseText) {
            const lowerResponse = responseText.toLowerCase();
            return SEARCH_SUGGESTION_PHRASES.some(phrase => lowerResponse.includes(phrase));
        }

        // Add a "Search for this?" button after the response
        function addSearchOfferButton(originalQuestion) {
            const container = document.getElementById('chatContainer');
            const offerDiv = document.createElement('div');
            offerDiv.className = 'search-offer';
            offerDiv.innerHTML = `
                <button class="search-offer-btn" onclick="performSearchFromOffer(this, '${originalQuestion.replace(/'/g, "\\'")}')">
                    <i data-lucide="search" style="width: 14px; height: 14px;"></i>
                    Search for this?
                </button>
            `;
            container.appendChild(offerDiv);
            container.scrollTop = container.scrollHeight;
            if (typeof lucide !== 'undefined') lucide.createIcons();
        }

        // Perform search when user clicks the offer button
        async function performSearchFromOffer(btn, question) {
            // Disable button and show loading
            btn.disabled = true;
            btn.innerHTML = '<i data-lucide="loader-2" class="spin" style="width: 14px; height: 14px;"></i> Searching...';
            if (typeof lucide !== 'undefined') lucide.createIcons();

            // Remove the offer button container
            const offerDiv = btn.closest('.search-offer');

            try {
                addTypingIndicator();

                const response = await authFetch('/api/chat', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        message: question,
                        character_id: currentCharacterId,
                        session_id: currentSessionId,
                        use_documents: true,
                        search: true
                    })
                });

                removeTypingIndicator();
                offerDiv.remove();

                if (response.ok) {
                    const data = await response.json();
                    if (data.response) {
                        currentSessionId = data.session_id;
                        localStorage.setItem('currentSessionId', currentSessionId);
                        addMessage('assistant', data.response);

                        if (data.web_search_results && data.web_search_results.length > 0) {
                            addSearchSources(data.web_search_results);
                        }

                        if (currentCharacterId) {
                            loadConversationHistory(currentCharacterId);
                        }
                    }
                } else {
                    showToast('Search failed', 'error');
                    offerDiv.remove();
                }
            } catch (e) {
                removeTypingIndicator();
                console.error('Search from offer failed:', e);
                showToast('Search failed', 'error');
                offerDiv.remove();
            }
        }

        // Add web search sources as clickable links
        function addSearchSources(results) {
            const container = document.getElementById('chatContainer');
            const sourcesDiv = document.createElement('div');
            sourcesDiv.className = 'search-sources';

            const sourcesHtml = results.map((result, i) => `
                <a href="${result.url}" target="_blank" rel="noopener noreferrer" class="search-source-link" title="${result.snippet || result.title}">
                    <span class="source-number">${i + 1}</span>
                    <span class="source-title">${result.title}</span>
                    <span class="source-domain">${result.source}</span>
                </a>
            `).join('');

            sourcesDiv.innerHTML = `
                <div class="sources-header">
                    <i data-lucide="globe" style="width: 12px; height: 12px;"></i>
                    Sources
                </div>
                <div class="sources-list">${sourcesHtml}</div>
            `;

            container.appendChild(sourcesDiv);
            container.scrollTop = container.scrollHeight;

            // Re-initialize Lucide icons
            if (typeof lucide !== 'undefined') lucide.createIcons();
        }

        function addMessage(sender, content) {
            const container = document.getElementById('chatContainer');
            const msg = document.createElement('div');
            msg.className = `message ${sender}`;
            // Convert URLs to clickable links in the content
            const linkedContent = linkifyUrls(content);
            msg.innerHTML = `
                <div class="message-sender">${sender === 'user' ? 'You' : currentPersona}</div>
                <div class="message-content">${linkedContent}</div>
            `;
            container.appendChild(msg);
            container.scrollTop = container.scrollHeight;
            chatHistory.push({ sender, content, timestamp: new Date() });
        }

        function addTypingIndicator() {
            const container = document.getElementById('chatContainer');
            const indicator = document.createElement('div');
            indicator.className = 'message assistant';
            indicator.id = 'typingIndicator';
            indicator.innerHTML = `
                <div class="message-sender">${currentPersona}</div>
                <div class="typing-indicator"><span></span><span></span><span></span></div>
            `;
            container.appendChild(indicator);
            container.scrollTop = container.scrollHeight;
        }

        function removeTypingIndicator() {
            const indicator = document.getElementById('typingIndicator');
            if (indicator) indicator.remove();
        }

        function clearChat() {
            document.getElementById('chatContainer').innerHTML = '';
            chatHistory = [];
        }

        async function loadExistingConversation() {
            if (!currentSessionId) return;

            authFetch(`/api/conversations/${currentSessionId}/history`)
                .then(r => r.json())
                .then(data => {
                    if (data && !data.error && data.character_id === currentCharacterId) {
                        clearChat();
                        data.history.forEach(msg => addMessage(msg.role, msg.content));
                    } else {
                        currentSessionId = null;
                        localStorage.removeItem('currentSessionId');
                        clearChat();
                        // Use personalized greeting
                        showPersonalizedGreeting(currentCharacterId, currentPersona);
                    }
                })
                .catch(() => {
                    currentSessionId = null;
                    localStorage.removeItem('currentSessionId');
                });
        }

        // ===== Sidebar Documents =====
        let currentTodos = [];
        let currentLifeAreas = {};
        let currentFeaturePreferences = null;

        // ===== Feature Preferences =====
        async function loadFeaturePreferences(characterId) {
            try {
                const response = await authFetch(`/api/feature-preferences/${characterId}`);
                if (!response.ok) throw new Error('Failed to load feature preferences');
                const data = await response.json();
                currentFeaturePreferences = data.effective;
                return data.effective;
            } catch (e) {
                console.error('Failed to load feature preferences:', e);
                // Return defaults
                return { goals: true, habits: true, todos: true, life_areas: false };
            }
        }

        async function updateFeaturePreference(feature, enabled) {
            if (!currentCharacterId) return;

            try {
                const response = await authFetch(`/api/feature-preferences/${currentCharacterId}/${feature}`, {
                    method: 'PUT',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ feature, enabled })
                });
                if (!response.ok) throw new Error('Failed to update');

                const data = await response.json();
                currentFeaturePreferences = data.effective;

                // Re-apply visibility
                applyFeatureVisibility();
            } catch (e) {
                console.error('Failed to update feature preference:', e);
            }
        }

        async function resetFeaturePreferences() {
            if (!currentCharacterId) return;

            try {
                const response = await authFetch(`/api/feature-preferences/${currentCharacterId}`, {
                    method: 'DELETE'
                });
                if (!response.ok) throw new Error('Failed to reset');

                // Reload preferences (now using defaults)
                await loadFeaturePreferences(currentCharacterId);
                applyFeatureVisibility();
            } catch (e) {
                console.error('Failed to reset feature preferences:', e);
            }
        }

        function applyFeatureVisibility() {
            const todoSection = document.getElementById('todoSection');
            const goalsSection = document.getElementById('goalsSection');
            const habitsSection = document.getElementById('habitsSection');
            const lifeAreasSection = document.getElementById('lifeAreasSection');
            const sidebarDocs = document.getElementById('sidebarDocuments');

            if (!currentFeaturePreferences || !currentCharacterId) {
                sidebarDocs.style.display = 'none';
                return;
            }

            // Check if any feature is enabled
            const anyEnabled = currentFeaturePreferences.goals ||
                               currentFeaturePreferences.habits ||
                               currentFeaturePreferences.todos ||
                               currentFeaturePreferences.life_areas;

            sidebarDocs.style.display = anyEnabled ? 'block' : 'none';

            // Apply visibility based on preferences
            todoSection.style.display = currentFeaturePreferences.todos ? 'block' : 'none';
            if (currentFeaturePreferences.todos) loadTodos(currentCharacterId);

            goalsSection.style.display = currentFeaturePreferences.goals ? 'block' : 'none';
            if (currentFeaturePreferences.goals) loadGoals(currentCharacterId);

            habitsSection.style.display = currentFeaturePreferences.habits ? 'block' : 'none';
            if (currentFeaturePreferences.habits) loadHabits(currentCharacterId);

            lifeAreasSection.style.display = currentFeaturePreferences.life_areas ? 'block' : 'none';
            if (currentFeaturePreferences.life_areas) loadLifeAreas(currentCharacterId);

            // Update icons
            if (typeof lucide !== 'undefined') lucide.createIcons();
        }

        async function updateSidebarDocuments(category) {
            const sidebarDocs = document.getElementById('sidebarDocuments');

            if (!currentCharacterId) {
                sidebarDocs.style.display = 'none';
                return;
            }

            // Load feature preferences and apply visibility
            await loadFeaturePreferences(currentCharacterId);
            applyFeatureVisibility();
        }

        // ===== Todo Functions =====
        async function loadTodos(characterId) {
            try {
                const response = await authFetch(`/api/todos?character_id=${characterId}`);
                if (!response.ok) throw new Error('Failed to load');
                const data = await response.json();
                currentTodos = data.todos || [];
                renderTodos();
            } catch (e) {
                console.error('Failed to load todos:', e);
                document.getElementById('todoList').innerHTML =
                    '<p class="text-muted text-sm text-center" style="padding: var(--space-2);">Failed to load</p>';
            }
        }

        function renderTodos() {
            const container = document.getElementById('todoList');
            if (currentTodos.length === 0) {
                container.innerHTML = `
                    <p class="text-muted text-sm text-center" style="padding: var(--space-3);">
                        No tasks yet. Add one above or say "add to my todo" in chat.
                    </p>
                `;
                return;
            }

            container.innerHTML = currentTodos.map(todo => `
                <div class="todo-item ${todo.is_completed ? 'completed' : ''} todo-priority-${todo.priority}"
                     data-todo-id="${todo.id}">
                    <label class="todo-checkbox">
                        <input type="checkbox" ${todo.is_completed ? 'checked' : ''}
                               onchange="toggleTodo(${todo.id})">
                    </label>
                    <span class="todo-text">${escapeHtml(todo.text)}</span>
                    <button class="todo-delete" onclick="deleteTodo(${todo.id})" title="Delete">
                        <i data-lucide="x" style="width: 14px; height: 14px;"></i>
                    </button>
                </div>
            `).join('');

            if (typeof lucide !== 'undefined') lucide.createIcons();
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        async function toggleTodo(todoId) {
            try {
                await authFetch(`/api/todos/${todoId}/toggle`, { method: 'PUT' });
                await loadTodos(currentCharacterId);
            } catch (e) {
                showToast('Failed to update todo', 'error');
            }
        }

        async function deleteTodo(todoId) {
            try {
                await authFetch(`/api/todos/${todoId}`, { method: 'DELETE' });
                await loadTodos(currentCharacterId);
            } catch (e) {
                showToast('Failed to delete todo', 'error');
            }
        }

        function addTodoInline() {
            document.getElementById('todoAddForm').style.display = 'flex';
            document.getElementById('newTodoInput').focus();
        }

        function cancelAddTodo() {
            document.getElementById('todoAddForm').style.display = 'none';
            document.getElementById('newTodoInput').value = '';
        }

        async function saveTodo() {
            const input = document.getElementById('newTodoInput');
            const text = input.value.trim();
            if (!text) return;

            try {
                await authFetch('/api/todos', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        character_id: currentCharacterId,
                        text: text,
                        priority: 2
                    })
                });
                cancelAddTodo();
                await loadTodos(currentCharacterId);
            } catch (e) {
                showToast('Failed to add todo', 'error');
            }
        }

        function exportTodos() {
            if (!currentTodos || currentTodos.length === 0) {
                showToast('No todos to export', 'error');
                return;
            }

            // Build simple text content
            const personaName = document.getElementById('currentPersonaName')?.textContent || 'Todo';
            let text = personaName + ' Todo List\n';
            text += new Date().toLocaleDateString() + '\n\n';

            currentTodos.forEach(function(todo) {
                const check = todo.is_completed ? '[x]' : '[ ]';
                text += check + ' ' + todo.text + '\n';
            });

            // Download as text file
            const blob = new Blob([text], { type: 'text/plain' });
            const a = document.createElement('a');
            a.href = URL.createObjectURL(blob);
            a.download = 'todo-list.txt';
            a.click();
            URL.revokeObjectURL(a.href);
        }

        // ===== Life Areas Functions =====
        async function loadLifeAreas(characterId) {
            try {
                const response = await authFetch(`/api/life-areas?character_id=${characterId}`);
                if (!response.ok) throw new Error('Failed to load');
                const data = await response.json();
                currentLifeAreas = data.scorecard || {};
                renderLifeAreas(data.average);
            } catch (e) {
                console.error('Failed to load life areas:', e);
                document.getElementById('lifeAreasGrid').innerHTML =
                    '<p class="text-muted text-sm text-center" style="padding: var(--space-2); grid-column: 1/-1;">Failed to load</p>';
            }
        }

        function renderLifeAreas(average) {
            const container = document.getElementById('lifeAreasGrid');
            const avgDisplay = document.getElementById('lifeAreasAverage');

            avgDisplay.textContent = `Avg: ${average || '--'}`;

            const areaNames = {
                'career': 'Career',
                'finances': 'Money',
                'health': 'Health',
                'relationships': 'Love',
                'family': 'Family',
                'friendships': 'Friends',
                'growth': 'Growth',
                'recreation': 'Fun',
                'environment': 'Home',
                'contribution': 'Giving'
            };

            const areas = Object.entries(currentLifeAreas);

            container.innerHTML = areas.map(([area, data]) => {
                const score = data.score || 5;
                const scoreClass = score <= 3 ? 'score-low' : score <= 6 ? 'score-medium' : 'score-high';
                return `
                    <div class="life-area-item" onclick="editLifeArea('${area}')"
                         title="Click to update score">
                        <span class="life-area-name">${areaNames[area] || area}</span>
                        <div class="life-area-score">
                            <span class="life-area-score-value ${scoreClass}">${score}</span>
                            <div class="life-area-bar">
                                <div class="life-area-bar-fill" style="width: ${score * 10}%"></div>
                            </div>
                        </div>
                    </div>
                `;
            }).join('');
        }

        const lifeAreaNames = {
            'career': 'Career/Work',
            'finances': 'Finances',
            'health': 'Health',
            'relationships': 'Relationships',
            'family': 'Family',
            'friendships': 'Friendships',
            'growth': 'Personal Growth',
            'recreation': 'Fun/Recreation',
            'environment': 'Environment',
            'contribution': 'Contribution'
        };

        function editLifeArea(area) {
            const current = currentLifeAreas[area]?.score || 5;
            showLifeAreaModal(area, lifeAreaNames[area] || area, current);
        }

        function showLifeAreaModal(area, areaName, currentScore) {
            // Remove any existing modal
            closeLifeAreaModal();

            // Create overlay
            const overlay = document.createElement('div');
            overlay.className = 'life-area-modal-overlay';
            overlay.id = 'lifeAreaModalOverlay';
            overlay.onclick = function(e) {
                if (e.target === overlay) closeLifeAreaModal();
            };

            // Build numbered boxes HTML (1-10)
            let boxesHtml = '';
            for (let i = 1; i <= 10; i++) {
                const selected = i === currentScore ? 'selected' : '';
                const colorClass = i <= 3 ? 'score-low' : i <= 6 ? 'score-medium' : 'score-high';
                boxesHtml += `<button class="life-area-score-box ${selected} ${colorClass}"
                                      data-score="${i}" onclick="selectLifeAreaScore('${area}', ${i})">${i}</button>`;
            }

            overlay.innerHTML = `
                <div class="life-area-modal">
                    <div class="life-area-modal-header">
                        <h4>Rate your ${areaName}</h4>
                        <button class="btn btn-ghost btn-sm" onclick="closeLifeAreaModal()" style="padding: 4px;">
                            <i data-lucide="x" style="width: 16px; height: 16px;"></i>
                        </button>
                    </div>
                    <p class="text-sm text-muted" style="margin-bottom: var(--space-3);">Click a number to set your rating</p>
                    <div class="life-area-score-boxes">${boxesHtml}</div>
                </div>
            `;
            document.body.appendChild(overlay);
            if (typeof lucide !== 'undefined') lucide.createIcons();
        }

        function selectLifeAreaScore(area, score) {
            updateLifeAreaScore(area, score);
            closeLifeAreaModal();
        }

        function closeLifeAreaModal() {
            const overlay = document.getElementById('lifeAreaModalOverlay');
            if (overlay) overlay.remove();
        }

        async function updateLifeAreaScore(area, score) {
            try {
                await authFetch(`/api/life-areas/${area}`, {
                    method: 'PUT',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        character_id: currentCharacterId,
                        score: score
                    })
                });
                await loadLifeAreas(currentCharacterId);
            } catch (e) {
                showToast('Failed to update score', 'error');
            }
        }

        // ===== Goals Functions =====
        let currentGoals = [];

        async function loadGoals(characterId) {
            try {
                const response = await authFetch(`/api/tracking/goals?character_id=${characterId}`);
                if (!response.ok) throw new Error('Failed to load');
                const data = await response.json();
                currentGoals = data.goals || [];
                renderGoals();
            } catch (e) {
                console.error('Failed to load goals:', e);
                document.getElementById('goalsList').innerHTML =
                    '<p class="text-muted text-sm text-center" style="padding: var(--space-2);">Failed to load</p>';
            }
        }

        function renderGoals() {
            const container = document.getElementById('goalsList');
            if (currentGoals.length === 0) {
                container.innerHTML = `
                    <p class="text-muted text-sm text-center" style="padding: var(--space-3);">
                        No goals yet. Click + to add one.
                    </p>
                `;
                return;
            }

            container.innerHTML = currentGoals.map(goal => {
                const progress = goal.progress_percentage || 0;
                const unit = (goal.unit || '').toLowerCase();
                const completionUnits = ['days', 'day', 'times', 'sessions', 'workouts', 'entries', 'essays'];
                const isCompletion = completionUnits.includes(unit);
                const progressText = goal.target_value
                    ? `${Math.floor(goal.current_value || 0)} / ${goal.target_value} ${goal.unit || ''}`
                    : `${Math.round(progress)}%`;
                const isComplete = goal.status === 'completed' || (goal.target_value && goal.current_value >= goal.target_value);

                const actionButton = isCompletion
                    ? `<button class="sidebar-goal-btn" onclick="event.stopPropagation(); checkInGoal(${goal.id})" ${isComplete ? 'disabled' : ''}>
                           <i data-lucide="check-circle" style="width: 12px; height: 12px;"></i> +1
                       </button>`
                    : `<button class="sidebar-goal-btn" onclick="event.stopPropagation(); logGoalProgress(${goal.id})" ${isComplete ? 'disabled' : ''}>
                           <i data-lucide="plus" style="width: 12px; height: 12px;"></i> Log
                       </button>`;

                return `
                    <div class="goal-item ${isComplete ? 'completed' : ''}" data-goal-id="${goal.id}">
                        <div class="goal-header">
                            <span class="goal-title">${escapeHtml(goal.title)}</span>
                            <button class="goal-delete-btn" onclick="event.stopPropagation(); deleteGoal(${goal.id})" title="Delete">
                                <i data-lucide="x" style="width: 12px; height: 12px;"></i>
                            </button>
                        </div>
                        <div class="goal-progress-bar">
                            <div class="goal-progress-fill" style="width: ${Math.min(100, progress)}%"></div>
                        </div>
                        <div class="goal-meta">
                            <span>${progressText} (${Math.round(progress)}%)</span>
                            ${actionButton}
                        </div>
                    </div>
                `;
            }).join('');

            if (typeof lucide !== 'undefined') lucide.createIcons();
        }

        async function checkInGoal(goalId) {
            try {
                const response = await authFetch(`/api/tracking/goals/${goalId}/progress`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ value_change: 1 })
                });
                if (response.ok) {
                    await loadGoals(currentCharacterId);
                }
            } catch (e) {
                console.error('Check-in failed:', e);
            }
        }

        async function logGoalProgress(goalId) {
            const value = prompt('Enter progress to add:');
            if (!value) return;

            const numValue = parseFloat(value);
            if (isNaN(numValue)) {
                alert('Please enter a valid number');
                return;
            }

            try {
                const response = await authFetch(`/api/tracking/goals/${goalId}/progress`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ value_change: numValue })
                });
                if (response.ok) {
                    await loadGoals(currentCharacterId);
                }
            } catch (e) {
                console.error('Log progress failed:', e);
            }
        }

        async function deleteGoal(goalId) {
            if (!confirm('Delete this goal?')) return;

            try {
                await authFetch(`/api/tracking/goals/${goalId}`, { method: 'DELETE' });
                await loadGoals(currentCharacterId);
            } catch (e) {
                console.error('Delete failed:', e);
            }
        }

        function showAddGoalModal() {
            const title = prompt('Goal title:');
            if (!title) return;

            const targetValue = prompt('Target value (optional, e.g., 10):');
            const unit = targetValue ? prompt('Unit (e.g., lbs, books, miles):') : null;

            createGoal(title, targetValue ? parseFloat(targetValue) : null, unit);
        }

        async function createGoal(title, targetValue, unit) {
            try {
                await authFetch('/api/tracking/goals', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        character_id: currentCharacterId,
                        title: title,
                        target_value: targetValue,
                        unit: unit
                    })
                });
                await loadGoals(currentCharacterId);
                showToast('Goal added!', 'success');
            } catch (e) {
                showToast('Failed to add goal', 'error');
            }
        }

        async function updateGoal(goalId, updates) {
            try {
                await authFetch(`/api/tracking/goals/${goalId}`, {
                    method: 'PUT',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(updates)
                });
                await loadGoals(currentCharacterId);
                showToast('Goal updated!', 'success');
            } catch (e) {
                showToast('Failed to update goal', 'error');
            }
        }

        // ===== Habits Functions =====
        let currentHabits = [];

        async function loadHabits(characterId) {
            try {
                const response = await authFetch(`/api/tracking/habits?character_id=${characterId}`);
                if (!response.ok) throw new Error('Failed to load');
                const data = await response.json();
                currentHabits = data.habits || [];
                renderHabits();
            } catch (e) {
                console.error('Failed to load habits:', e);
                document.getElementById('habitsList').innerHTML =
                    '<p class="text-muted text-sm text-center" style="padding: var(--space-2);">Failed to load</p>';
            }
        }

        function renderHabits() {
            const container = document.getElementById('habitsList');
            if (currentHabits.length === 0) {
                container.innerHTML = `
                    <p class="text-muted text-sm text-center" style="padding: var(--space-3);">
                        No habits yet. Click + to add one.
                    </p>
                `;
                return;
            }

            container.innerHTML = currentHabits.map(habit => {
                const isCompleted = habit.completed_today;
                const streak = habit.current_streak || 0;
                const streakClass = streak > 0 ? 'active' : '';

                return `
                    <div class="habit-item">
                        <button class="habit-check-btn ${isCompleted ? 'completed' : ''}"
                                onclick="toggleHabit(${habit.id}, ${isCompleted})"
                                title="${isCompleted ? 'Completed today!' : 'Mark as done'}">
                            ${isCompleted ? '<i data-lucide="check" style="width: 14px; height: 14px;"></i>' : ''}
                        </button>
                        <div class="habit-info" onclick="showHabitDetails(${habit.id})">
                            <div class="habit-title">${escapeHtml(habit.title)}</div>
                            ${streak > 0 ? `<div class="habit-streak ${streakClass}"> ${streak} day streak</div>` : ''}
                        </div>
                    </div>
                `;
            }).join('');

            if (typeof lucide !== 'undefined') lucide.createIcons();
        }

        function showAddHabitModal() {
            const title = prompt('Habit name (e.g., "Exercise 30 min"):');
            if (!title) return;

            createHabit(title);
        }

        async function createHabit(title) {
            try {
                await authFetch('/api/tracking/habits', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        character_id: currentCharacterId,
                        title: title,
                        frequency: 'daily'
                    })
                });
                await loadHabits(currentCharacterId);
                showToast('Habit added!', 'success');
            } catch (e) {
                showToast('Failed to add habit', 'error');
            }
        }

        async function toggleHabit(habitId, isCurrentlyCompleted) {
            if (isCurrentlyCompleted) {
                // Already completed today, do nothing or show message
                showToast('Already completed today!', 'info');
                return;
            }

            try {
                await authFetch(`/api/tracking/habits/${habitId}/complete`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({})
                });
                await loadHabits(currentCharacterId);
                showToast('Great job! ', 'success');
            } catch (e) {
                showToast('Failed to complete habit', 'error');
            }
        }

        async function showHabitDetails(habitId) {
            const habit = currentHabits.find(h => h.id === habitId);
            if (!habit) return;

            const action = prompt(
                `${habit.title}\n` +
                `Streak: ${habit.current_streak || 0} days\n` +
                `Best: ${habit.longest_streak || 0} days\n\n` +
                `Type "delete" to remove this habit:`
            );

            if (action && action.toLowerCase() === 'delete') {
                await deleteHabit(habitId);
            }
        }

        async function deleteHabit(habitId) {
            try {
                await authFetch(`/api/tracking/habits/${habitId}`, { method: 'DELETE' });
                await loadHabits(currentCharacterId);
                showToast('Habit deleted', 'success');
            } catch (e) {
                showToast('Failed to delete habit', 'error');
            }
        }

        // Export functionality
        let selectedExportFormat = 'pdf';
        let currentCharacterCategory = 'Assistant';
        let documentTypesCache = {};

        function toggleExportDropdown(event) {
            event.stopPropagation();
            const dropdown = document.getElementById('exportDropdownContent');
            dropdown.classList.toggle('show');

            // Load document types for current character category
            if (dropdown.classList.contains('show')) {
                loadDocumentTypes(currentCharacterCategory);
                document.addEventListener('click', closeExportDropdown);
            }
        }

        function closeExportDropdown() {
            const dropdown = document.getElementById('exportDropdownContent');
            dropdown.classList.remove('show');
            document.removeEventListener('click', closeExportDropdown);
        }

        async function loadDocumentTypes(category) {
            const section = document.getElementById('documentTypesSection');
            const list = document.getElementById('documentTypesList');
            const header = document.getElementById('documentTypesHeader');

            if (!category) {
                section.style.display = 'none';
                return;
            }

            // Check cache first
            if (documentTypesCache[category]) {
                renderDocumentTypes(documentTypesCache[category], category);
                return;
            }

            try {
                const response = await authFetch(`/api/export/document-types/${category}`);
                if (response.ok) {
                    const data = await response.json();
                    documentTypesCache[category] = data.document_types;
                    renderDocumentTypes(data.document_types, category);
                }
            } catch (error) {
                console.error('Failed to load document types:', error);
                section.style.display = 'none';
            }
        }

        function renderDocumentTypes(docTypes, category) {
            const section = document.getElementById('documentTypesSection');
            const list = document.getElementById('documentTypesList');
            const header = document.getElementById('documentTypesHeader');

            if (!docTypes || docTypes.length === 0) {
                section.style.display = 'none';
                return;
            }

            section.style.display = 'block';
            header.textContent = `Generate ${category} Document`;

            list.innerHTML = docTypes.map(dt => `
                <button class="export-dropdown-item" onclick="generateDocument('${dt.id}')" title="${dt.description}">
                    <i data-lucide="sparkles" class="export-icon"></i>
                    <span class="export-label">${dt.name}</span>
                    <span class="export-ext">.${selectedExportFormat}</span>
                </button>
            `).join('');

            // Reinitialize Lucide icons for new elements
            if (typeof lucide !== 'undefined') lucide.createIcons();
        }

        // Format button handlers
        document.addEventListener('DOMContentLoaded', function() {
            document.querySelectorAll('.format-btn').forEach(btn => {
                btn.addEventListener('click', function(e) {
                    e.stopPropagation();
                    document.querySelectorAll('.format-btn').forEach(b => b.classList.remove('active'));
                    this.classList.add('active');
                    selectedExportFormat = this.dataset.format;

                    // Update extension displays
                    document.querySelectorAll('#documentTypesList .export-ext').forEach(ext => {
                        ext.textContent = '.' + selectedExportFormat;
                    });
                });
            });
        });

        async function exportConversation(format) {
            closeExportDropdown();

            if (!currentSessionId) {
                alert('No active conversation to export');
                return;
            }

            try {
                const response = await authFetch(`/api/export/conversation/${currentSessionId}`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        format: format,
                        include_system: false,
                        include_timestamps: true
                    })
                });

                if (!response.ok) {
                    const error = await response.json();
                    throw new Error(error.detail || 'Export failed');
                }

                downloadFile(response, `conversation.${format}`);

            } catch (error) {
                console.error('Export error:', error);
                alert('Failed to export conversation: ' + error.message);
            }
        }

        async function generateDocument(documentType) {
            closeExportDropdown();

            if (!currentSessionId) {
                alert('No active conversation to generate document from');
                return;
            }

            // Show loading state
            const exportBtn = document.querySelector('#exportDropdown > button');
            const originalTitle = exportBtn.title;
            exportBtn.title = 'Generating document...';
            exportBtn.style.opacity = '0.5';
            exportBtn.disabled = true;

            try {
                const response = await authFetch(`/api/export/generate/${currentSessionId}`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        document_type: documentType,
                        format: selectedExportFormat,
                        sfw_mode: true
                    })
                });

                if (!response.ok) {
                    const error = await response.json();
                    throw new Error(error.detail || 'Document generation failed');
                }

                downloadFile(response, `document.${selectedExportFormat}`);

            } catch (error) {
                console.error('Document generation error:', error);
                alert('Failed to generate document: ' + error.message);
            } finally {
                exportBtn.title = originalTitle;
                exportBtn.style.opacity = '';
                exportBtn.disabled = false;
            }
        }

        async function downloadFile(response, defaultFilename) {
            // Get filename from Content-Disposition header
            const contentDisposition = response.headers.get('Content-Disposition');
            let filename = defaultFilename;
            if (contentDisposition) {
                const match = contentDisposition.match(/filename="(.+)"/);
                if (match) {
                    filename = match[1];
                }
            }

            // Download the file
            const blob = await response.blob();
            const url = window.URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            window.URL.revokeObjectURL(url);
            a.remove();
        }

        // Update character category when character changes
        function updateCharacterCategory(category) {
            currentCharacterCategory = category || 'Assistant';
            // Clear cache to force reload on next dropdown open
            delete documentTypesCache[currentCharacterCategory];
        }

        // Sidebar
        function toggleHistoryCollapse() {
            const wrapper = document.querySelector('.conversation-history-wrapper');
            const header = wrapper.querySelector('.sidebar-section-collapsible');
            const content = wrapper.querySelector('.conversation-history');

            header.classList.toggle('collapsed');
            content.classList.toggle('collapsed');

            if (typeof lucide !== 'undefined') lucide.createIcons();
        }

        function toggleTodoCollapse(event) {
            if (event) event.stopPropagation();
            const section = document.getElementById('todoSection');
            const header = section.querySelector('.sidebar-section-collapsible');
            const content = section.querySelector('.todo-list');

            header.classList.toggle('collapsed');
            content.classList.toggle('collapsed');

            if (typeof lucide !== 'undefined') lucide.createIcons();
        }

        function toggleGoalsCollapse(event) {
            if (event) event.stopPropagation();
            const section = document.getElementById('goalsSection');
            const header = section.querySelector('.sidebar-section-collapsible');
            const content = section.querySelector('.goals-list');

            header.classList.toggle('collapsed');
            content.classList.toggle('collapsed');

            if (typeof lucide !== 'undefined') lucide.createIcons();
        }

        function toggleHabitsCollapse(event) {
            if (event) event.stopPropagation();
            const section = document.getElementById('habitsSection');
            const header = section.querySelector('.sidebar-section-collapsible');
            const content = section.querySelector('.habits-list');

            header.classList.toggle('collapsed');
            content.classList.toggle('collapsed');

            if (typeof lucide !== 'undefined') lucide.createIcons();
        }

        function toggleLifeAreasCollapse(event) {
            if (event) event.stopPropagation();
            const section = document.getElementById('lifeAreasSection');
            const header = section.querySelector('.sidebar-section-collapsible');
            const content = section.querySelector('.life-areas-grid');

            header.classList.toggle('collapsed');
            content.classList.toggle('collapsed');

            if (typeof lucide !== 'undefined') lucide.createIcons();
        }

        function toggleSidebar() {
            sidebarCollapsed = !sidebarCollapsed;
            const sidebar = document.getElementById('chatSidebar');
            const backdrop = document.getElementById('sidebarBackdrop');

            sidebar.classList.toggle('collapsed', sidebarCollapsed);

            // Handle mobile backdrop
            if (window.innerWidth <= 768) {
                if (sidebarCollapsed) {
                    backdrop.classList.remove('show');
                    document.body.style.overflow = '';
                } else {
                    backdrop.classList.add('show');
                    document.body.style.overflow = 'hidden';
                }
            }
        }

        // Close sidebar when clicking backdrop on mobile
        document.getElementById('sidebarBackdrop').addEventListener('click', function() {
            if (!sidebarCollapsed) {
                toggleSidebar();
            }
        });

        // Handle window resize - close sidebar on mobile when resizing
        window.addEventListener('resize', function() {
            const backdrop = document.getElementById('sidebarBackdrop');
            if (window.innerWidth > 768) {
                backdrop.classList.remove('show');
                document.body.style.overflow = '';
            }
        });

        // File upload
        function toggleFileUpload() {
            const zone = document.getElementById('fileUploadArea');
            if (zone.classList.contains('active')) {
                zone.classList.remove('active');
                selectedFile = null;
                document.getElementById('uploadedFileInfo').innerHTML = '';
            } else {
                zone.classList.add('active');
            }
        }

        const fileUploadArea = document.getElementById('fileUploadArea');
        const fileInput = document.getElementById('fileInput');

        ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(e => {
            fileUploadArea.addEventListener(e, ev => { ev.preventDefault(); ev.stopPropagation(); }, false);
        });

        ['dragenter', 'dragover'].forEach(e => {
            fileUploadArea.addEventListener(e, () => fileUploadArea.classList.add('dragover'), false);
        });

        ['dragleave', 'drop'].forEach(e => {
            fileUploadArea.addEventListener(e, () => fileUploadArea.classList.remove('dragover'), false);
        });

        fileUploadArea.addEventListener('drop', e => handleFiles(e.dataTransfer.files));
        fileInput.addEventListener('change', e => handleFiles(e.target.files));

        // Enable drag-and-drop anywhere on the chat area
        const chatMain = document.querySelector('.chat-main');
        if (chatMain) {
            ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(e => {
                chatMain.addEventListener(e, ev => { ev.preventDefault(); ev.stopPropagation(); }, false);
            });

            chatMain.addEventListener('dragenter', () => {
                chatMain.classList.add('drag-active');
            });

            chatMain.addEventListener('dragleave', (e) => {
                // Only remove if leaving the chat area entirely
                if (!chatMain.contains(e.relatedTarget)) {
                    chatMain.classList.remove('drag-active');
                }
            });

            chatMain.addEventListener('drop', e => {
                chatMain.classList.remove('drag-active');
                if (e.dataTransfer.files.length > 0) {
                    handleFiles(e.dataTransfer.files);
                }
            });
        }

        function handleFiles(files) {
            if (files.length > 0) {
                selectedFile = files[0];
                showFileInfo(selectedFile);
            }
        }

        function showFileInfo(file) {
            const sizeKB = (file.size / 1024).toFixed(1);
            document.getElementById('uploadedFileInfo').innerHTML = `
                <div class="uploaded-file">
                    <i data-lucide="file" style="width: 16px; height: 16px;"></i>
                    <span>${file.name} (${sizeKB} KB)</span>
                    <span class="remove-file" onclick="removeFile()">
                        <i data-lucide="x" style="width: 14px; height: 14px;"></i>
                    </span>
                </div>
            `;
            lucide.createIcons();
        }

        function removeFile() {
            selectedFile = null;
            document.getElementById('uploadedFileInfo').innerHTML = '';
            fileInput.value = '';
        }

        // Chat form
        document.getElementById('chatForm').addEventListener('submit', function(e) {
            e.preventDefault();
            const input = document.getElementById('messageInput');
            const message = input.value.trim();

            if (!message && !selectedFile) return;
            if (!currentCharacterId) {
                showToast('Please select a persona first', 'error');
                return;
            }

            addMessage('user', message || '[Document uploaded]');
            input.value = '';
            addTypingIndicator();

            // Track user messages for auto-collapse of LLM banner
            userMessageCount++;
            if (userMessageCount >= 2) {
                const llmBanner = document.getElementById('llmInfoBanner');
                if (llmBanner && llmBanner.classList.contains('show')) {
                    // Auto-collapse after 2 user messages
                    llmBanner.classList.add('auto-collapsed');
                    setTimeout(() => {
                        llmBanner.classList.remove('show');
                        llmBanner.classList.remove('auto-collapsed');
                    }, 500);
                }
            }

            if (selectedFile) {
                document.getElementById('processingStatus').classList.add('show');
            }

            const formData = new FormData();
            formData.append('message', message || 'Please analyze the uploaded document.');
            formData.append('character_id', currentCharacterId);
            if (currentSessionId) formData.append('session_id', currentSessionId);
            formData.append('use_documents', 'true');
            if (selectedFile) formData.append('file', selectedFile);

            const endpoint = selectedFile ? '/api/chat/with-document' : '/api/chat';
            const options = selectedFile ?
                { method: 'POST', body: formData } :
                {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        message, character_id: currentCharacterId,
                        session_id: currentSessionId, use_documents: true
                    })
                };

            authFetch(endpoint, options)
                .then(r => r.json())
                .then(data => {
                    removeTypingIndicator();
                    document.getElementById('processingStatus').classList.remove('show');

                    if (data.response) {
                        const isNewConversation = !currentSessionId || currentSessionId !== data.session_id;
                        currentSessionId = data.session_id;
                        localStorage.setItem('currentSessionId', currentSessionId);

                        // Refresh conversation history if this is a new conversation
                        if (isNewConversation && currentCharacterId) {
                            loadConversationHistory(currentCharacterId);
                        }

                        // Refresh again after delay to pick up LLM-generated title
                        // Title is generated after 2nd message, so always check after a short delay
                        if (currentCharacterId) {
                            setTimeout(() => {
                                loadConversationHistory(currentCharacterId);
                            }, 4000);
                        }

                        // Show LLM info banner if using default LLM
                        const llmBanner = document.getElementById('llmInfoBanner');
                        const llmText = document.getElementById('llmInfoText');
                        const llmLink = document.getElementById('llmBannerLink');
                        const llmDismiss = document.getElementById('llmBannerDismiss');

                        // Check if user dismissed the banner for this character
                        const dismissedKey = `llmBannerDismissed_${currentCharacterId}`;
                        const wasDismissed = localStorage.getItem(dismissedKey) === 'true';

                        if (data.using_default_llm && data.llm_message && !wasDismissed) {
                            llmText.textContent = data.llm_message;
                            // Only link to persona edit if we have a valid character ID
                            if (currentCharacterId) {
                                llmLink.href = `/persona/edit/${currentCharacterId}`;
                                llmLink.textContent = 'Configure';
                                llmLink.style.display = 'inline';
                            } else {
                                llmLink.href = '/settings';
                                llmLink.textContent = 'Settings';
                                llmLink.style.display = 'inline';
                            }
                            llmDismiss.style.display = 'inline';
                            llmBanner.classList.add('show', 'warning');
                        } else if (data.llm_provider && data.llm_model && !wasDismissed) {
                            // Show current LLM info (non-warning)
                            llmText.textContent = `Using ${data.llm_provider}/${data.llm_model}`;
                            if (currentCharacterId) {
                                llmLink.href = `/persona/edit/${currentCharacterId}`;
                                llmLink.textContent = 'Edit';
                                llmLink.style.display = 'inline';
                            } else {
                                llmLink.style.display = 'none';
                            }
                            llmDismiss.style.display = 'inline';
                            llmBanner.classList.remove('warning');
                            llmBanner.classList.add('show');
                        }

                        let content = data.response;
                        if (data.uploaded_document?.analysis) {
                            content += generateDocumentAnalysisHTML(data.uploaded_document.analysis);
                        }
                        if (data.sources?.length > 0) {
                            content += `<div class="document-analysis"><strong>Sources:</strong><div style="margin-top: var(--space-2);">${renderSources(data.sources)}</div></div>`;
                        }

                        // Add tracking cards if present
                        if (data.tracking_cards?.length > 0) {
                            content += renderTrackingCards(data.tracking_cards);
                        }

                        addMessage('assistant', content);

                        // Offer search if LLM couldn't answer and character has search capability
                        if (webSearchEnabled && shouldOfferSearch(data.response)) {
                            addSearchOfferButton(message);
                        }

                        // Refresh Lucide icons for any new tracking cards
                        if (data.tracking_cards?.length > 0 && typeof lucide !== 'undefined') {
                            lucide.createIcons();
                        }

                        // Handle sidebar extractions (todos, life areas, goals, habits)
                        if (data.sidebar_extractions) {
                            const extractions = data.sidebar_extractions;
                            const todoCount = extractions.todos?.length || 0;
                            const lifeAreaCount = extractions.life_areas?.length || 0;
                            const goalCount = extractions.goals?.length || 0;
                            const habitCount = extractions.habits?.length || 0;

                            if (todoCount > 0 || lifeAreaCount > 0 || goalCount > 0 || habitCount > 0) {
                                // Show toast notification
                                let toastParts = [];
                                if (todoCount > 0) {
                                    toastParts.push(`${todoCount} todo${todoCount > 1 ? 's' : ''}`);
                                    if (currentCharacterId) loadTodos(currentCharacterId); // Refresh sidebar
                                }
                                if (goalCount > 0) {
                                    toastParts.push(`${goalCount} goal${goalCount > 1 ? 's' : ''}`);
                                    if (currentCharacterId) loadGoals(currentCharacterId); // Refresh sidebar
                                }
                                if (habitCount > 0) {
                                    toastParts.push(`${habitCount} habit${habitCount > 1 ? 's' : ''}`);
                                    if (currentCharacterId) loadHabits(currentCharacterId); // Refresh sidebar
                                }
                                if (lifeAreaCount > 0) {
                                    toastParts.push(`${lifeAreaCount} life area${lifeAreaCount > 1 ? 's' : ''}`);
                                    if (currentCharacterId) loadLifeAreas(currentCharacterId); // Refresh sidebar
                                }

                                // Simple toast (reusing LLM banner temporarily)
                                console.log('Sidebar extraction: Added', toastParts.join(', '));
                            }
                        }

                        // Always hide upload zone after successful message
                        document.getElementById('fileUploadArea').classList.remove('active');
                        if (selectedFile) {
                            removeFile();
                        }
                    } else {
                        addMessage('assistant', 'Sorry, I encountered an error. Please try again.');
                    }
                })
                .catch(err => {
                    removeTypingIndicator();
                    document.getElementById('processingStatus').classList.remove('show');
                    addMessage('assistant', 'Sorry, I encountered an error. Please try again.');
                });
        });

        function generateDocumentAnalysisHTML(analysis) {
            if (!analysis) return '';
            let html = '<div class="document-analysis"><strong>Document Analysis:</strong>';
            if (analysis.summary) html += `<p>${analysis.summary}</p>`;
            if (analysis.key_points?.length) {
                html += '<ul>' + analysis.key_points.map(p => `<li>${p}</li>`).join('') + '</ul>';
            }
            html += '</div>';
            return html;
        }

        function renderSources(sources) {
            return sources.map(s => {
                const name = typeof s === 'string' ? s : (s.filename || s.document_filename || 'Document');
                return `<span class="source-citation"><i data-lucide="file-text" style="width: 12px; height: 12px;"></i> ${name}</span>`;
            }).join('');
        }

        // Document panel
        function toggleDocumentPanel() {
            documentPanelOpen ? closeDocumentPanel() : openDocumentPanel();
        }

        function openDocumentPanel() {
            if (!currentCharacterId) {
                showToast('Please select a persona first', 'error');
                return;
            }
            document.getElementById('documentOverlay').classList.add('show');
            document.getElementById('documentPanel').classList.add('open');
            documentPanelOpen = true;
            loadCharacterDocuments();
        }

        function closeDocumentPanel() {
            document.getElementById('documentOverlay').classList.remove('show');
            document.getElementById('documentPanel').classList.remove('open');
            documentPanelOpen = false;
        }

        async function loadCharacterDocuments() {
            const container = document.getElementById('documentList');
            container.innerHTML = '<p class="text-muted text-center"><span class="spinner spinner-sm"></span> Loading...</p>';

            try {
                const r = await authFetch(`/api/documents/characters/${currentCharacterId}/documents`);
                const data = await r.json();

                if (r.ok && data.documents?.length) {
                    container.innerHTML = data.documents.map(doc => `
                        <div class="document-item">
                            <div style="display: flex; align-items: center; gap: var(--space-2);">
                                <i data-lucide="file-text" style="width: 20px; height: 20px; color: var(--text-muted);"></i>
                                <div>
                                    <div style="font-weight: var(--font-medium);">${doc.original_filename}</div>
                                    <div class="text-muted text-xs">${formatFileSize(doc.file_size)} &bull; ${doc.processing_status}</div>
                                </div>
                            </div>
                        </div>
                    `).join('') + `
                        <div style="margin-top: var(--space-4);">
                            <a href="/documents" class="btn btn-secondary" style="width: 100%;">Manage Documents</a>
                        </div>
                    `;
                    lucide.createIcons();
                } else {
                    container.innerHTML = `
                        <div class="text-center" style="padding: var(--space-8);">
                            <i data-lucide="file-x" style="width: 48px; height: 48px; color: var(--text-muted);"></i>
                            <p class="text-muted" style="margin-top: var(--space-4);">No documents assigned</p>
                            <a href="/documents" class="btn btn-secondary" style="margin-top: var(--space-2);">Upload Documents</a>
                        </div>
                    `;
                    lucide.createIcons();
                }
            } catch (err) {
                container.innerHTML = '<p class="text-muted text-center">Error loading documents</p>';
            }
        }

        function formatFileSize(bytes) {
            if (!bytes) return '0 B';
            const k = 1024;
            const sizes = ['B', 'KB', 'MB', 'GB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return parseFloat((bytes / Math.pow(k, i)).toFixed(1)) + ' ' + sizes[i];
        }

        // Toast notification
        function showToast(message, type = 'info') {
            const container = document.getElementById('toast-container') || createToastContainer();
            const toast = document.createElement('div');
            toast.className = `toast toast-${type}`;
            toast.innerHTML = `<span>${message}</span>`;
            container.appendChild(toast);
            setTimeout(() => {
                toast.style.animation = 'slideIn 0.3s ease reverse';
                setTimeout(() => toast.remove(), 300);
            }, 4000);
        }

        function createToastContainer() {
            const container = document.createElement('div');
            container.id = 'toast-container';
            container.className = 'toast-container';
            document.body.appendChild(container);
            return container;
        }
    </script>
</body>
</html>
